; Implementation of _complete_ term rewriting system in Egison

(load-file "term.egi")

(define $equation
  (matcher
     ; undirected equation
    {[<equation $ $> [term term]
      {[<Equation $l $r> {[l r] [r l]}]
       [_ {}]}]
     ; directed equation
     [<dequation $ $> [term term]
      {[<Equation $l $r> {[l r]}]
       [_ {}]}]
     [$ something
      {[$tgt {tgt}]}]
     }))

(define $eql (lambda [$x $y] <Equation x y>))

(define $efv
  (lambda [$eq]
    (unique
      (match eq equation
        {[<equation $l $r> (append (fv l) (fv r))]}))))

(define $esubst
  (match-lambda [something equation]
    {[[$u <equation $l $r>] <Equation (tsubst u l) (tsubst u r)>]}))

; {equation} -> term -> term
; free variables of axioms and tm should be disjoint!!!
(define $rewrite
  (lambda [$axioms $tm]
    (match [tm axioms] [term (multiset equation)]
      {[[<subterm-nonv $subtm $context>
         <cons <dequation <unify' ,subtm $sigma> $r> _>]
        (rewrite axioms (debug/fn show-term (context (tsubst sigma r))))
        ]
       [_ tm]
       })))

(assert-equal "rewrite 1"
  (rewrite axioms-of-nat (app "+" two one))
  three)
(assert-equal "rewrite 2"
  (rewrite axioms-of-groups (p (p x4 (i x4)) e))
  e)
(assert-equal "rewrite 3"
  (rewrite axioms-of-groups (p (p x4 x5) (i (p x4 x5))))
  e)
(assert-equal "rewrite 4"
  (rewrite axioms-of-groups (p e x))
  (p e x))
(assert-equal "rewrite 5"
  (rewrite axioms-of-nat (app "+" (app "S" x4) (app "S" x5)))
  (app "+" x4 (app "S" (app "S" x5))))

;;======================= Knuth-Bendix completion ==============================

; rename free variables of each axioms so that they don't collide
(define $rename-problem
  (match-lambda [integer (list equation)]
    {[[$n <nil>]
      {}]
     [[$n <cons $e $es>]
      (let {[$u (zip (efv e)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (esubst u e)
              (rename-problem (+ n (length u)) es)))]}))

(define $rename-problem'
  (lambda [$axioms $eq]
    (let {[$r (rename-problem 0 {eq @axioms})]}
      [(cdr r) (car r)])))

(define $unique-unordered-pairs
  (lambda [$xs]
    (letrec {[$loop-fn
              (lambda [$xs $ys]
                (match [xs ys] [(list equation) (multiset equation)]
                  {[[<nil> _] ys]
                   [[<cons $x $rs> <cons ,x _>] (loop-fn rs ys)]
                   [[<cons <equation $l $r> $rs> <cons <equation ,r ,l> _>]
                      (loop-fn rs ys)]
                   [[<cons $x $rs>  _] (loop-fn rs {@ys x})]}))]}
      (loop-fn xs {}))))

;; {equation} -> {[term term]}
(define $critical-pairs
  (lambda [$axioms]
    (match-all (rename-problem 0 axioms) (set equation)
      {[<cons <equation $l1 $r1>
        <cons <equation (& !,l1 <subterm <unify ,l1 $sigma> $context>) $r2> _>>
        [(tsubst sigma r2) (tsubst sigma (context r1))]
        ]
       })))

;; {equation} -> equation -> {[term term]}
(define $critical-pairs'
  (lambda [$axioms $new-axiom]
    (match-all (rename-problem' axioms new-axiom) [(multiset equation) equation]
      {[[<cons <equation $l1 $r1> _>
         <equation (& !,l1 <subterm <unify ,l1 $sigma> $context>) $r2>]
        [(tsubst sigma r2) (tsubst sigma (context r1))]]
       [[<cons <equation (later (& !,l1 <subterm <unify ,l1 $sigma> $context>)) $r2> _>
         <equation $l1 $r1>]
        [(tsubst sigma r2) (tsubst sigma (context r1))]]
       })))

(define $orient-equation
  (match-lambda [term term]
    {[[$l $r]
      (if (succ? l r) (eql l r) (eql r l))]}))

(define $complete-loop
  (lambda [$axioms $crits]
    (io (do
      {[(print
          (S.concat {(show (length axioms)) " axioms, "
                     (show (length crits)) " pending critical pairs"}))]}
      (return
        (let {[$. (report axioms crits)]}
          (match crits (list [term term])
            {[<nil> axioms]
             [<cons [$l $r] $crits'>
              (let {[$l' (rewrite axioms (debug/fn show-term l))]
                    [$r' (rewrite axioms (debug/fn show-term r))]}
                (if (eq? l' r')
                    (complete-loop axioms crits')
                    (let {[$new-axiom
                           (debug/fn show-equation (orient-equation l' r'))]}
                      (complete-loop
                        {@axioms new-axiom}
                        (union crits (critical-pairs' axioms new-axiom))))))
              ]})))))))

(define $complete
  (lambda [$axioms]
    (complete-loop axioms
                   (critical-pairs axioms))))

;;==============================================================================

(define $show-equation
  (match-lambda equation
    {[<equation $x $y> (S.concat {(show-term x) " = " (show-term y)})]}))

(define $show-equations
  (col-show/fn show-equation $1))

;;==============================================================================

(define $p (app "*" $1 $2)) ; product
(define $i (app "i" $1))    ; inverse
(define $e (app "e"))       ; 単位元

(define $a' (i a))
(define $b' (i b))
(define $c' (i c))
(define $d' (i d))

(define $x' (i x))
(define $y' (i y))
(define $z' (i z))
(define $w' (i w))

(define $axioms-of-groups
  {(eql (p x x') e)            ; x * x' = e
   (eql (p x e) x)             ; x * e = x
   (eql (p (p x y) z) (p x (p y z)))
  })

(define $axioms-of-groups-complete
  {@axioms-of-groups
   (eql (i (p y x)) (p x' y')) ; (y * x)' = x' * y'
   (eql (p y' (p y x)) x)      ; y' * (y * x) = x
   (eql (p x' x) e)            ; x' * x = e
   (eql (i e) e)               ; e' = e
   (eql (i x') x)              ; x'' = x
   (eql (p e x) x)             ; e * x = x
   (eql (p x (p x' y)) y)      ; x * (x' * y) = y
  })

; (a * a')' = e
(define $g1' (i (p a a')))
(define $g1 (eql g1' e))

; (((b * c) * d)' * b)' * d' = c
(define $g2' (p (i (p (i (p (p b c) d)) b))
                (i d)))
(define $g2 (eql g2' c))
; (((b * c) * d)' * b)' * d'
; = (d' * (b * c)' * b)' * d'
; = (d' * c' * b' * b)' * d'
; = (d' * c' * e)' * d'
; = (d' * c')' * d'
; = c'' * d'' * d'
; = c'' * d * d'
; = c'' * e
; = c * e
; = c

(define $g3 (eql (p g1' g2') c))

; e * a = a
(define $g4 (eql (p e a) a))

; a' * a = e
(define $g5 (eql (p a' a) e))

;;==============================================================================

(define $zero  (app "O"))
(define $one   (app "S" (app "O")))
(define $two   (app "S" (app "S" (app "O"))))
(define $three (app "S" (app "S" (app "S" (app "O")))))
(define $four  (app "S" (app "S" (app "S" (app "S" (app "O"))))))

(define $axioms-of-nat
   ; O + x = x
  {(eql (app "+" zero x) x)
   ; S(m) + n = m + S(n)
   (eql (app "+" (app "S" x) y) (app "+" x (app "S" y)))
   })

(define $p7 (eql (app "+" one two) three))
(define $p8 (eql (app "+" zero two) two))

;;==============================================================================

; small example from
; https://github.com/mir-ikbch/compl_coq/blob/8.5/test-suite/test.v

(define $op (app "*" $1 $2))

; (x * y) * (y * z) = y
(define $axioms-ikebuchi
  {(eql (op (op x y) (op y z)) y)})

; ex.
; ((a * b) * (b * c)) * ((b * c) * c) = b * c

; completion result in PLAR program:
; [<<(x3 * x0 * x1) * x1 = x0 * x1>>; <<x1 * (x1 * x2) * x5 = x1 * x2>>;
;  <<(x * y) * y * z = y>>]

;;==============================================================================

; small example from PLAR

; f(f(x)) = g(x)
(define $axioms-plar
  {(eql (app "f" (app "f" x)) (app "g" x))})

; completion result:
; f(g(x)) = g(f(x)), g(x) = g(x)
