(load-file "rewrite.egi")
(load-file "example.egi")

;;======================= Knuth-Bendix completion ==============================

(define $rename-pair
  (lambda [$eq1 $eq2]
    (let* {[$fvs1 (efv eq1)]
           [$fvs2 (efv eq2)]
           [$sigma1 (zip fvs1 (map (lambda $x <Var x>) (from 0)))]
           [$sigma2 (zip fvs2 (map (lambda $x <Var x>) (from (length fvs1))))]}
      [(esubst sigma1 eq1) (esubst sigma2 eq2)]
      )))

;; [equation equation] -> {[term term]}
(define $critical-pairs'
  (match-all-lambda [equation equation]
    {[[<dequation $l1 $r1>
       <dequation (& !,l1 <subterm-nonv <unify ,l1 $sigma> $context>) $r2>]
      [(tsubst sigma r2) (tsubst sigma (context r1))]]
     }))

;; [equation equation] -> {[term term]}
(define $critical-pairs
  (match-lambda [equation equation]
    {[[$eq1 ,eq1] (critical-pairs' (rename-pair [eq1 eq1]))]
     [[$eq1 $eq2]
      (let {[[$eq1' $eq2'] (rename-pair [eq1 eq2])]}
        {@(critical-pairs' [eq1' eq2']) @(critical-pairs' [eq2' eq1'])})]
     }))

(define $critical-pairs-for-set
  (lambda [$eqs]
    (concat
      (match-all eqs (set equation)
        {[<cons $eq1 <cons $eq2 _>>
          (critical-pairs' (rename-pair [eq1 eq2]))]
        }))))

(define $orient
  (lambda [$l $r]
    (if (succ? l r)
        (Just (eql l r))
        (if (succ? r l)
            (Just (eql r l))
            Nothing))))

(define $report
  (lambda [$eqs $crits $deferred]
    (print
      (S.concat {(show (length eqs)) " eqs, "
                 (show (length crits)) " pending critical pairs; "
                 (show (length deferred)) " deferred"}))))

; TODO: handle deferred critical pairs
(define $complete-loop
  (lambda [$eqs $crits $deferred]
    (io (do {[(report eqs crits deferred)]
             ; [(print (show-critical-pair (car crits)))]
             }
      (return
        (match [crits deferred] [(list [term term]) (list [term term])]
          {[[<nil> <nil>] eqs]
           [[<nil> <cons [$l $r] $defs'>]
            (match (orient l r) (maybe something)
              {[(just $new-axiom)
                (let {[$new-eqs {@eqs (debug/fn show-equation new-axiom)}]
                      [$new-crits (concat (map (critical-pairs new-axiom $1) new-eqs))]}
                  (complete-loop new-eqs new-crits defs'))
                ]
               [(nothing) {}]})] ; failed completion
           [[<cons [$l $r] $crits'> _]
            (let {[$l' (rewrite eqs l)]
                  [$r' (rewrite eqs r)]}
              (if (eq? l' r')
                  (complete-loop eqs crits' deferred)
                  (match (orient l' r') (maybe something)
                    {[(just $new-axiom)
                      (let* {[$new-eqs {@eqs (debug/fn show-equation new-axiom)}]
                             [$new-crits (concat (map (critical-pairs new-axiom $1) new-eqs))]}
                        (complete-loop
                          new-eqs
                          {@crits' @new-crits}
                          deferred))
                      ]
                     [(nothing)
                      (complete-loop eqs crits' (cons [l' r'] deferred))
                      ]
                     })))]}))))))

(define $complete
  (lambda [$eqs]
    (complete-loop eqs
                   (critical-pairs-for-set eqs)
                   {})))

;;==============================================================================

(define $show-critical-pair
  (match-lambda [term term]
    {[[$l $r] (S.concat {"[" (show-term l) ", " (show-term r) "]"})]}))

(define $show-critical-pairs
  (col-show/fn show-critical-pair $1))

; [(x3 * x4,(x0 * x3 * x4) * x4),(x4 * x5,x4 * (x4 * x5) * x2),(x1,x1)]
;
; {[x4, ((x * w * x4) * (w * x4) * z) * x4 * x5],
;  [x4, x4],
;  [x4, (w * x4) * (x * x4 * x5) * (x4 * x5) * z],
;  [x4, (x * (w * x4) * x4 * x5) * ((w * x4) * x4 * x5) * z]}
