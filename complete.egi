(load-file "rewrite.egi")
(load-file "example.egi")

;;======================= Knuth-Bendix completion ==============================

; rename free variables of each axioms so that they don't collide
(define $rename-problem
  (match-lambda [integer (list equation)]
    {[[$n <nil>]
      {}]
     [[$n <cons $e $es>]
      (let {[$u (zip (efv e)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (esubst u e)
              (rename-problem (+ n (length u)) es)))]}))

(define $rename-problem'
  (lambda [$axioms $eq]
    (let {[$r (rename-problem 0 {eq @axioms})]}
      [(cdr r) (car r)])))

;; {equation} -> {[term term]}
(define $critical-pairs
  (lambda [$axioms]
    (match-all (rename-problem 0 axioms) (set equation)
      {[<cons <equation $l1 $r1>
        <cons <equation (& !,l1 <subterm <unify ,l1 $sigma> $context>) $r2> _>>
        [(tsubst sigma r2) (tsubst sigma (context r1))]
        ]
       })))

;; {equation} -> equation -> {[term term]}
(define $critical-pairs'
  (lambda [$axioms $new-axiom]
    (match-all (rename-problem' axioms new-axiom) [(multiset equation) equation]
      {[[<cons <equation $l1 $r1> _>
         <equation (& !,l1 <subterm <unify ,l1 $sigma> $context>) $r2>]
        [(tsubst sigma r2) (tsubst sigma (context r1))]]
       [[<cons <equation (later (& !,l1 <subterm <unify ,l1 $sigma> $context>)) $r2> _>
         <equation $l1 $r1>]
        [(tsubst sigma r2) (tsubst sigma (context r1))]]
       })))

(define $orient-equation
  (match-lambda [term term]
    {[[$l $r]
      (if (succ? l r) (eql l r) (eql r l))]}))

(define $complete-loop
  (lambda [$axioms $crits]
    (io (do
      {[(print
          (S.concat {(show (length axioms)) " axioms, "
                     (show (length crits)) " pending critical pairs"}))]}
      (return
        (match crits (list [term term])
          {[<nil> axioms]
           [<cons [$l $r] $crits'>
            (let {[$l' (rewrite axioms (debug/fn show-term l))]
                  [$r' (rewrite axioms (debug/fn show-term r))]}
              (if (eq? l' r')
                  (complete-loop axioms crits')
                  (let {[$new-axiom
                         (debug/fn show-equation (orient-equation l' r'))]}
                    (complete-loop
                      {@axioms new-axiom}
                      (union crits (critical-pairs' axioms new-axiom))))))
            ]}))))))

(define $complete
  (lambda [$axioms]
    (complete-loop axioms
                   (critical-pairs axioms))))

;;==============================================================================

(define $show-critical-pair
  (match-lambda [term term]
    {[[$l $r] (S.concat {"[" (show-term l) ", " (show-term r) "]"})]}))

(define $show-critical-pairs
  (col-show/fn show-critical-pair $1))
