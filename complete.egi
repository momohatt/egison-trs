(load-file "rewrite.egi")
(load-file "example.egi")

;;======================= Knuth-Bendix completion ==============================

(define $rename-pair
  (lambda [$eq1 $eq2]
    (let* {[$fvs1 (efv eq1)]
           [$fvs2 (efv eq2)]
           [$sigma1 (zip fvs1 (map (lambda $x <Var x>) (from 0)))]
           [$sigma2 (zip fvs2 (map (lambda $x <Var x>) (from (length fvs1))))]}
      [(esubst sigma1 eq1) (esubst sigma2 eq2)]
      )))

;; [equation equation] -> {[term term]}
(define $critical-pairs'
  (match-all-lambda [equation equation]
    {[[<dequation $l1 $r1>
       <dequation (& !,l1 <subterm-nonv <unify ,l1 $sigma> $context>) $r2>]
      [(tsubst sigma r2) (tsubst sigma (context r1))]]
     }))

;; [equation equation] -> {[term term]}
(define $critical-pairs
  (match-lambda [equation equation]
    {[[$eq1 ,eq1] (critical-pairs' (rename-pair [eq1 eq1]))]
     [[$eq1 $eq2]
      (let {[[$eq1' $eq2'] (rename-pair [eq1 eq2])]}
        {@(critical-pairs' [eq1' eq2']) @(critical-pairs' [eq2' eq1'])})]
     }))

(define $critical-pairs-for-set
  (lambda [$axioms]
    (concat
      (match-all axioms (set equation)
        {[<cons $eq1 <cons $eq2 _>>
          (critical-pairs [eq1 eq2])]
        }))))

; TODO
(define $orient
  (match-lambda [term term]
    {[[$l $r]
      (if (succ? l r) (eql l r) (eql r l))]}))

(define $report
  (lambda [$axioms $crits]
    (print
      (S.concat {(show (length axioms)) " axioms, "
                 (show (length crits)) " pending critical pairs"}))))

(define $complete-loop
  (lambda [$axioms $crits]
    (io (do {[(report axioms crits)]}
      (return
        (match crits (list [term term])
          {[<nil> axioms]
           [<cons [$l $r] $crits'>
            (let {[$l' (rewrite axioms (debug/fn show-term l))]
                  [$r' (rewrite axioms (debug/fn show-term r))]}
              (if (eq? l' r')
                  (complete-loop axioms crits')
                  (let* {[$new-axiom (orient l' r')]
                         [$new-crits (concat (map (critical-pairs new-axiom $1) axioms))]}
                    (complete-loop
                      {@axioms new-axiom}
                      {@crits @new-crits}))))
            ]}))))))

(define $complete
  (lambda [$axioms]
    (complete-loop axioms
                   (critical-pairs-for-set axioms))))

;;==============================================================================

(define $show-critical-pair
  (match-lambda [term term]
    {[[$l $r] (S.concat {"[" (show-term l) ", " (show-term r) "]"})]}))

(define $show-critical-pairs
  (col-show/fn show-critical-pair $1))

; [(x3 * x4,(x0 * x3 * x4) * x4),(x4 * x5,x4 * (x4 * x5) * x2),(x1,x1)]
;
; {[x4, ((x * w * x4) * (w * x4) * z) * x4 * x5],
;  [x4, x4],
;  [x4, (w * x4) * (x * x4 * x5) * (x4 * x5) * z],
;  [x4, (x * (w * x4) * x4 * x5) * ((w * x4) * x4 * x5) * z]}
