(load-file "rewrite.egi")
(load-file "example.egi")

;;======================= Knuth-Bendix completion ==============================

(define $rename-pair
  (lambda [$eq1 $eq2]
    (let* {[$fvs1 (efv eq1)]
           [$fvs2 (efv eq2)]
           [$sigma1 (zip fvs1 (map (lambda $x <Var x>) (from 0)))]
           [$sigma2 (zip fvs2 (map (lambda $x <Var x>) (from (length fvs1))))]}
      [(esubst sigma1 eq1) (esubst sigma2 eq2)]
      )))

;; [equation equation] -> {[term term]}
(define $critical-pairs
  (match-all-lambda [equation equation]
    {[[<dequation $l1 $r1>
       <dequation <subterm-nonv <unify ,l1 $sigma> $context> $r2>]
      [(tsubst sigma r2) (tsubst sigma (context r1))]]
     }))

;; equation -> {equation} -> {[term term]}
(define $critical-pairs-for-new-eq
  (lambda [$new-eq $eqs]
    (concat
      (match-all eqs (multiset equation)
        {[<cons ,new-eq _>
          (critical-pairs (rename-pair new-eq new-eq))]
         [<cons (& $eq !,new-eq) _>
          {@(critical-pairs (rename-pair eq new-eq))
           @(critical-pairs (rename-pair new-eq eq))}]
         }))))

;; {equation} -> {[term term]}
(define $critical-pairs-for-set
  (lambda [$eqs]
    (concat
      (match-all eqs (set equation)
        {[<cons $eq1 <cons $eq2 _>>
          (critical-pairs (rename-pair [eq1 eq2]))]}))))

(define $orient
  (lambda [$l $r]
    (if (succ? l r)
        (Just (eql l r))
        (if (succ? r l)
            (Just (eql r l))
            Nothing))))

(define $report
  (lambda [$eqs $crits $deferred]
    (print
      (S.concat {(show (length eqs)) " eqs, "
                 (show (length crits)) " pending critical pairs; "
                 (show (length deferred)) " deferred"}))))

(define $term-pair
  (matcher
    {[<normalize-and-orient ,$eqs $> equation
      {[[$l $r]
        (orient (rewrite eqs l) (rewrite eqs r))]
       [_ {}]}]
     [[$ $] [term term]
      {[[$l $r] {[l r]}]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $complete-loop-slow
  (lambda [$eqs $crits]
    (io (do {[(report eqs crits {})]}
      (return
        (match crits (multiset term-pair)
          {; No pending or deferred critical pairs
           [<nil> (interreduce eqs)]

           [<cons ?(joinable? eqs $ $) $crits'>
            (complete-loop-slow eqs crits')]
           [<cons <normalize-and-orient ,eqs $new-eq> $crits'>
            (let* {[$new-eqs
                     {@(interreduce eqs) (debug/fn show-equation new-eq)}]
                   [$new-crits
                     (critical-pairs-for-new-eq new-eq new-eqs)]}
                   (complete-loop-slow new-eqs {@crits' @new-crits}))]
           [_ {}]
           }))))))

(define $complete-loop
  (lambda [$eqs $crits $deferred]
    (io (do {[(report eqs crits deferred)]} ; 途中経過の出力
      (return
        ; Note how deferred critical pair should be treated as 'multiset'
        (match [crits deferred] [(list term-pair) (multiset term-pair)]
          {; No pending or deferred critical pairs
           [[<nil> <nil>] (interreduce eqs)]

           ; No pending critical pairs, but there are some deferred ones
           [[<nil> <cons ?(joinable? $ $) $defs'>]
            (complete-loop eqs crits defs')]
           [[<nil> <cons <normalize-and-orient ,eqs $new-eq> $defs'>]
            (let* {[$new-eqs
                     {@(interreduce eqs) (debug/fn show-equation new-eq)}]
                   [$new-crits
                     (critical-pairs-for-new-eq new-eq new-eqs)]}
                   (complete-loop new-eqs new-crits defs'))]
           [[<nil> _] {}] ; completion failed

           ; There are some pending critical pairs
           [[<cons ?(joinable? eqs $ $) $crits'> _]
            (complete-loop eqs crits' deferred)]
           [[<cons <normalize-and-orient ,eqs $new-eq> $crits'> _]
            (let* {[$new-eqs
                     {@(interreduce eqs) (debug/fn show-equation new-eq)}]
                   [$new-crits
                     (critical-pairs-for-new-eq new-eq new-eqs)]}
                   (complete-loop new-eqs {@crits' @new-crits} deferred))]
           [[<cons [$l $r] $crits'> _]
            (complete-loop eqs crits' (cons [l r] deferred))]
           }))))))

(define $complete
  (lambda [$eqs]
    (complete-loop eqs (critical-pairs-for-set eqs) {})))

;; {equation} -> {equation}
(define $interreduce
  (match-lambda (multiset equation)
    {[<cons <dequation $l $r> (& $others ?(joinable? $ l r))>
      (interreduce (debug/fn show-equations others))]
     [$eqs eqs]
     }))

;;==============================================================================

(define $show-term-pair
  (match-lambda [term term]
    {[[$l $r] (S.concat {"[" (show-term l) ", " (show-term r) "]"})]}))

(define $show-term-pairs
  (col-show/fn show-term-pair $1))

;;==============================================================================

; completion result without interreduction
(define $axioms-of-groups-completion-result
  {
   <Equation <Compound "*" {<Compound "e" {}> <Var 0>}> <Var 0>>
   <Equation <Compound "*" {<Compound "i" {<Var 0>}> <Var 0>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Compound "*" {<Var 0> <Var 1>}> <Var 2>}> <Compound "*" {<Var 0> <Compound "*" {<Var 1> <Var 2>}>}>>
   <Equation <Compound "*" {<Compound "i" {<Var 0>}> <Compound "*" {<Var 0> <Var 2>}>}> <Var 2>>
   <Equation <Compound "*" {<Compound "i" {<Compound "e" {}>}> <Var 3>}> <Var 3>>
   <Equation <Compound "*" {<Compound "i" {<Compound "i" {<Var 3>}>}> <Compound "e" {}>}> <Var 3>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 4> <Var 5>}>}> <Compound "*" {<Var 4> <Compound "*" {<Var 5> <Var 3>}>}>}> <Var 3>>
   <Equation <Compound "*" {<Compound "i" {<Compound "i" {<Var 0>}>}> <Var 2>}> <Compound "*" {<Var 0> <Var 2>}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "e" {}>}>}> <Compound "*" {<Var 0> <Var 5>}>}> <Var 5>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "i" {<Var 5>}>}>}> <Compound "*" {<Var 0> <Compound "e" {}>}>}> <Var 5>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Compound "i" {<Compound "*" {<Var 2> <Var 4>}>}> <Var 2>}>}> <Compound "e" {}>}> <Var 4>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 6> <Compound "*" {<Var 7> <Var 5>}>}>}> <Compound "*" {<Var 6> <Compound "*" {<Var 7> <Compound "*" {<Var 5> <Var 4>}>}>}>}> <Var 4>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "i" {<Var 5>}>}>}> <Compound "*" {<Var 0> <Var 7>}>}> <Compound "*" {<Var 5> <Var 7>}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Var 2>}>}> <Var 0>}>}> <Var 4>}> <Compound "*" {<Var 2> <Var 4>}>>
   <Equation <Compound "*" {<Var 1> <Compound "i" {<Var 1>}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Var 1> <Compound "*" {<Compound "i" {<Var 1>}> <Var 4>}>}> <Var 4>>
   <Equation <Compound "*" {<Var 1> <Compound "e" {}>}> <Var 1>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 4> <Compound "*" {<Var 5> <Compound "i" {<Var 2>}>}>}>}> <Compound "*" {<Var 4> <Var 5>}>}> <Var 2>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 3> <Compound "i" {<Var 2>}>}>}> <Var 3>}> <Var 2>>
   <Equation <Compound "i" {<Compound "*" {<Compound "i" {<Compound "*" {<Var 4> <Compound "*" {<Var 5> <Var 3>}>}>}> <Compound "*" {<Var 4> <Var 5>}>}>}> <Var 3>>
   <Equation <Compound "i" {<Compound "*" {<Compound "i" {<Var 5>}> <Compound "i" {<Var 3>}>}>}> <Compound "*" {<Var 3> <Var 5>}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "*" {<Compound "i" {<Compound "*" {<Var 4> <Var 6>}>}> <Var 4>}>}>}> <Var 0>}> <Var 6>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "*" {<Var 8> <Compound "*" {<Var 9> <Var 7>}>}>}>}> <Compound "*" {<Var 0> <Compound "*" {<Var 8> <Compound "*" {<Var 9> <Compound "*" {<Var 7> <Var 6>}>}>}>}>}> <Var 6>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "*" {<Var 2> <Compound "i" {<Var 7>}>}>}>}> <Compound "*" {<Var 0> <Compound "*" {<Var 2> <Var 9>}>}>}> <Compound "*" {<Var 7> <Var 9>}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 0> <Compound "*" {<Compound "i" {<Compound "*" {<Var 7> <Var 9>}>}> <Var 7>}>}>}> <Compound "*" {<Var 0> <Var 11>}>}> <Compound "*" {<Var 9> <Var 11>}>>
   <Equation <Compound "*" {<Var 3> <Compound "*" {<Compound "i" {<Compound "*" {<Var 1> <Var 3>}>}> <Var 1>}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Var 3> <Compound "*" {<Compound "i" {<Compound "*" {<Var 1> <Var 3>}>}> <Compound "*" {<Var 1> <Var 6>}>}>}> <Var 6>>
   <Equation <Compound "*" {<Var 3> <Compound "i" {<Compound "*" {<Compound "i" {<Var 6>}> <Var 3>}>}>}> <Var 6>>
   <Equation <Compound "i" {<Compound "*" {<Var 3> <Compound "i" {<Compound "*" {<Var 1> <Var 3>}>}>}>}> <Var 1>>
   <Equation <Compound "*" {<Var 3> <Compound "*" {<Compound "i" {<Compound "*" {<Var 6> <Compound "*" {<Var 8> <Var 3>}>}>}> <Compound "*" {<Var 6> <Compound "*" {<Var 8> <Var 10>}>}>}>}> <Var 10>>
   <Equation <Compound "*" {<Var 3> <Compound "*" {<Compound "i" {<Compound "*" {<Compound "i" {<Var 7>}> <Var 3>}>}> <Var 5>}>}> <Compound "*" {<Var 7> <Var 5>}>>
   <Equation <Compound "i" {<Compound "e" {}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Var 3> <Compound "*" {<Var 4> <Compound "i" {<Compound "*" {<Var 3> <Var 4>}>}>}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 2> <Var 0>}>}> <Var 2>}> <Compound "i" {<Var 0>}>>
   <Equation <Compound "*" {<Var 3> <Compound "i" {<Compound "i" {<Compound "i" {<Var 3>}>}>}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 2> <Compound "*" {<Var 4> <Var 0>}>}>}> <Compound "*" {<Var 2> <Var 4>}>}> <Compound "i" {<Var 0>}>>
   <Equation <Compound "i" {<Compound "*" {<Var 0> <Compound "i" {<Var 5>}>}>}> <Compound "*" {<Var 5> <Compound "i" {<Var 0>}>}>>
   <Equation <Compound "*" {<Var 4> <Compound "*" {<Var 5> <Compound "*" {<Compound "i" {<Compound "*" {<Var 4> <Var 5>}>}> <Var 1>}>}>}> <Var 1>>
   <Equation <Compound "*" {<Compound "i" {<Compound "*" {<Var 3> <Var 0>}>}> <Compound "*" {<Var 3> <Var 1>}>}> <Compound "*" {<Compound "i" {<Var 0>}> <Var 1>}>>
   <Equation <Compound "i" {<Compound "*" {<Compound "i" {<Var 1>}> <Var 0>}>}> <Compound "*" {<Compound "i" {<Var 0>}> <Var 1>}>>
   <Equation <Compound "i" {<Compound "i" {<Var 0>}>}> <Var 0>>
   <Equation <Compound "i" {<Compound "*" {<Var 1> <Var 0>}>}> <Compound "*" {<Compound "i" {<Var 0>}> <Compound "i" {<Var 1>}>}>>
 })

(define $axioms-of-groups-completion-result-interreduced
  {
   <Equation <Compound "*" {<Compound "e" {}> <Var 0>}> <Var 0>>
   <Equation <Compound "*" {<Compound "i" {<Var 0>}> <Var 0>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Compound "*" {<Var 0> <Var 1>}> <Var 2>}> <Compound "*" {<Var 0> <Compound "*" {<Var 1> <Var 2>}>}>>
   <Equation <Compound "*" {<Compound "i" {<Var 0>}> <Compound "*" {<Var 0> <Var 2>}>}> <Var 2>>
   <Equation <Compound "*" {<Var 1> <Compound "i" {<Var 1>}>}> <Compound "e" {}>>
   <Equation <Compound "*" {<Var 1> <Compound "*" {<Compound "i" {<Var 1>}> <Var 4>}>}> <Var 4>>
   <Equation <Compound "*" {<Var 1> <Compound "e" {}>}> <Var 1>>
   <Equation <Compound "i" {<Compound "e" {}>}> <Compound "e" {}>>
   <Equation <Compound "i" {<Compound "i" {<Var 0>}>}> <Var 0>>
   <Equation <Compound "i" {<Compound "*" {<Var 1> <Var 0>}>}> <Compound "*" {<Compound "i" {<Var 0>}> <Compound "i" {<Var 1>}>}>>
   })
