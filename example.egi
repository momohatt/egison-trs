(load-file "resolution.egi")

(define $x 0)
(define $y 1)
(define $z 2)
(define $w 3)
; P(g(x), y)
(define $t1 (pred "P" (app "g" (var x)) (var y)))
; P(g(g(c)), c)
(define $t2 (pred "P" (app "g" (app "g" (app "c"))) (app "c")))

(define $test-occur
  (lambda [$v $t]
    (match t term
      {[(occur ,v) #t]
       [_ #f]})))

(assert "occur1" (test-occur x t1))
(assert "occur2" (not (test-occur z t1)))

(assert "fv1"
  (match (fv t1) (multiset something)
   {[,{0 1} #t]
    [_ #f]}))

(assert-equal "fv2"
  (fv t2)
  {})

; [z / x, x / y] P(g(x), y) = P(g(z), x)
(assert-equal "subst1"
  (psubst {[y <Var x>] [x <Var z>]} t1)
  (pred "P" (app "g" (var z) (var x))))

; [z / z] P(g(x), y) = P(g(x), y)
(assert-equal "subst2"
  (psubst {[z <Var z>]} t1)
  (pred "P" (app "g" (var x)) (var y)))

(assert-equal "subst3"
  (psubst {[y <Var x>] [x <Var z>]}
    (eql (app "f" (var x)) (app "+" (var y) (var x))))
  (eql (app "f" (var z)) (app "+" (var x) (var z))))

; t1 = P(g(x), y)
; t2 = P(g(g(c)), c)
(assert-equal "unify1" (unify (var x) (var x)) {{}})
(assert-equal "unify2" (unify t1 (var z)) {{[z t1]}})
; {[x, g(c)], [y, c]}
(assert-equal "unify3" (unify-prop t1 t2) {{[0 <Compound "g" {<Compound "c" {}>}>] [1 <Compound "c" {}>]}})

; ========================= example (group theory) =============================

(define $t3 (pred "P" (var x) (app "f" (var x) (var y))))
(define $t4 (pred "P" (app "c") (var y)))

; 1. Problem:
; (\forall x y. \exists z. P(g(x),y) \to P(x,z))
; \land (\forall y. \lnot P(c,y)) \land P(g(g(c)),c)
; 2. Prenex normal form
; \forall x y. \exists z. (P(g(x),y) \to P(x,z))
; \land \lnot P(c,y) \land P(g(g(c)),c)
; 3. Skolemization
; \forall x y. (P(g(x),y) \to P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
; 4. Conjunction normal form
; (\lnot P(g(x),y) \lor P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
(define $p1 {{<Lit -1 t1> <Lit 1 t3>} {<Lit -1 t4>} {<Lit 1 t2>}})

; Drinker's paradox
; 1. \lnot \exists x. D(x) \to \forall y. D(y)
; 2. \forall x. \exists y. D(x) \land \lnot D(y)
; 3. \forall x. D(x) \land \lnot D(c)
; 4. D(x) \land \lnot D(c)
(define $p2
  {{<Lit 1 (pred "D" (var x))>} {<Lit -1 (pred "D" (app "c"))>}})

; Recall the axioms of groups:
; (1) (x*y)*z = x*(y*z)
; (2) x*(x^-1)= 1
; (3) (x^-1)*x = 1
; (4) x*1 = x
; (5) 1*x = x
; It is known that (3) and (5) above are redundant, i.e., provable from other axioms. Let's prove this!

(define $p (app "*" $1 $2)) ; product
(define $i (app "i" $1))    ; inverse
(define $e (app "e"))
(define $e1 (app "e1"))
(define $e2 (app "e2"))

; (a) axioms of groups
; - p(p(x,y),z) = p(x,p(y,z))
; - p(x,i(x)) = e
; - p(x,e) = x
; (b) axioms of equality
; - x = x
; - \lnot (x = y) \lor (y = x)
; - \lnot (x = y) \lor lnot (y = z) \lor (x = z)
; - \lnot (x = y) \lnot (z = w) \lor (p(x,z) = p(y,w))
; - \lnot (x = y) \lor (i(x) = i(y))
; (c) (negation) of the goal
; - \lnot (p(i(e1),e1) = e) \lor \lnot (p(e,e2) = e2)

(define $axioms-of-groups
  {{<Lit 1 (eql (p (p (var x) (var y)) (var z)) (p (var x) (p (var y) (var z))))>}
   {<Lit 1 (eql (p (var x) (i (var x))) e)>}
   {<Lit 1 (eql (p (var x) e) (var x))>}
  })

(define $axioms-of-equality
  {{<Lit 1 (eql (var x) (var x))>}
   {<Lit -1 (eql (var x) (var y))> <Lit 1 (eql (var y) (var x))>}
   {<Lit -1 (eql (var x) (var y))> <Lit -1 (eql (var y) (var z))> <Lit 1 (eql (var x) (var z))>}
  })

(define $congruence-groups
  {{<Lit -1 (eql (var x) (var y))> <Lit -1 (eql (var z) (var w))> <Lit 1 (eql (p (var x) (var z)) (p (var y) (var w)))>}
   {<Lit -1 (eql (var x) (var y))> <Lit 1 (eql (i (var x)) (i (var y)))>}
  })

; (1) (2) (4) |= (5)
(define $p3
  {@axioms-of-groups
   ; @axioms-of-equality
   ; @congruence-groups

   ; (negation of) the goal: e * x = x
   {<Lit -1 (eql (p e e1) e1)>}})

(assert-equal "solve3" (solve p3) <REFUTE>)

; (1) (2) (4) |= (3)
(define $p4
  {@axioms-of-groups
   ; @axioms-of-equality
   ; @congruence-groups

   ; (negation of) the goal: x^-1 * x = e
   {<Lit -1 (eql (p (i e2) e2) e)>}})

; ==============================================================================

(define $p5
  ; Issac is a boy
  {{<Lit 1 (pred "B" (app "i"))>}
   ; Kate is a girl
   {<Lit 1 (pred "G" (app "k"))>}
   ; Joe's friends are all tall
   {<Lit -1 (pred "F" (app "j") (var x))> <Lit 1 (pred "T" (var x))>}
   ; Harry loves any girl that is tall
   {<Lit -1 (pred "G" (var y))> <Lit -1 (pred "T" (var y))> <Lit 1 (pred "L" (app "h") (var y))>}
   ; Issac is a friend of Joe
   {<Lit 1 (pred "F" (app "j") (app "i"))>}
   ; Kate is a friend of Joe
   {<Lit 1 (pred "F" (app "j") (app "k"))>}

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   {<Lit -1 (pred "L" (app "h") (var z))> <Lit -1 (pred "F" (app "j") (var z))>}
  })

(define $p6
   ; Kate is a girl
  {{<Lit 1 (pred "G" (app "k"))>}
   ; Joe's friends are all tall
   {<Lit -1 (pred "F" (app "j") (var x))> <Lit 1 (pred "T" (var x))>}
   ; Harry loves any girl that is tall
   {<Lit -1 (pred "G" (var y))> <Lit -1 (pred "T" (var y))> <Lit 1 (pred "L" (app "h") (var y))>}
   ; Kate is a friend of Joe
   {<Lit 1 (pred "F" (app "j") (app "k"))>}

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   {<Lit -1 (pred "L" (app "h") (var z))> <Lit -1 (pred "F" (app "j") (var z))>}})

; ==============================================================================

(define $axioms-of-nat
   ; O + x = x
  {{<Lit 1 (eql (app "+" (app "O") (var x)) (var x))>}
   ; S(m) + n = m + S(n)
   {<Lit 1 (eql (app "+" (app "S" (var x)) (var y))
                (app "+" (var x) (app "S" (var y))))>}})

(define $zero  (app "O"))
(define $one   (app "S" (app "O")))
(define $two   (app "S" (app "S" (app "O"))))
(define $three (app "S" (app "S" (app "S" (app "O")))))
(define $four  (app "S" (app "S" (app "S" (app "S" (app "O"))))))

(define $p7
  {; @axioms-of-equality
   @axioms-of-nat
   ; S(O) + S(S(O)) = S(S(S(O)))
   {<Lit -1 (eql (app "+" one two) three)>}})

(define $p8
  {; @axioms-of-equality
   @axioms-of-nat
   ; O + S(S(O)) = S(S(O))
   {<Lit -1 (eql (app "+" zero two) two)>}})

(define $p9
  {{<Lit -1 (eql (var x) (var x))>}})
