(load-file "resolution.egi")

(define $x (var 0))
(define $y (var 1))
(define $z (var 2))
(define $w (var 3))
; P(g(x), y)
(define $t1 (pred "P" (app "g" x) y))
; P(g(g(c)), c)
(define $t2 (pred "P" (app "g" (app "g" (app "c"))) (app "c")))

(define $test-occur
  (lambda [$v $t]
    (match t term
      {[(occur ,v) #t]
       [_ #f]})))

(assert "occur1" (test-occur x t1))
(assert "occur2" (not (test-occur z t1)))

(assert "fv1"
  (match (pfv t1) (multiset integer)
    {[,{0 1} #t]
     [_ #f]}))
(assert-equal "cfv-eq"
  (cfv [#t {<Lit 1 (eql x y)> <Lit 1 (pred "P" z w)>}])
  {0 1 2 3})

(assert-equal "subterm1"
  ; x = (y + (z * w))
  (match-all (eql x (app "+" y (app "*" z w))) prop
    {[<subterm (& !<var _> $a) $env> [a (env (var 4))]]})
  {[(app "*" z w) (eql (app "+" y (var 4)) x)]
   [(app "+" y (app "*" z w)) (eql (var 4) x)]})

; [z / x, x / y] P(g(x), y) = P(g(z), x)
(assert-equal "subst1"
  (psubst {[1 x] [0 z]} t1)
  (pred "P" (app "g" z) x))

; [z / z] P(g(x), y) = P(g(x), y)
(assert-equal "subst2"
  (psubst {[2 z]} t1)
  (pred "P" (app "g" x) y))

(assert-equal "subst3"
  (psubst {[1 x] [0 z]}
    (eql (app "f" x) (app "+" y x)))
  (eql (app "f" z) (app "+" x z)))

(assert-equal "csubst1"
  (csubst {[1 x] [0 z]} [#t {<Lit 1 (eql x y)>}])
  [#t {<Lit 1 (eql z x)>}])
(assert-equal "csubst'1"
  (csubst' {[1 x] [0 z]} {<Lit 1 (eql x y)>})
  {<Lit 1 (eql z x)>})

; t1 = P(g(x), y)
; t2 = P(g(g(c)), c)
(assert-equal "unify1" (unify x x) {{}})
(assert-equal "unify2" (unify t1 z) {{[z t1]}})
; {[x, g(c)], [y, c]}
(assert-equal "unify3"
  (unify-prop t1 t2)
  {{[0 <Compound "g" {<Compound "c" {}>}>] [1 <Compound "c" {}>]}})

; ========================= example (group theory) =============================

(define $t3 (pred "P" x (app "f" x y)))
(define $t4 (pred "P" (app "c") y))

; 1. Problem:
; (\forall x y. \exists z. P(g(x),y) \to P(x,z))
; \land (\forall y. \lnot P(c,y)) \land P(g(g(c)),c)
; 2. Prenex normal form
; \forall x y. \exists z. (P(g(x),y) \to P(x,z))
; \land \lnot P(c,y) \land P(g(g(c)),c)
; 3. Skolemization
; \forall x y. (P(g(x),y) \to P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
; 4. Conjunction normal form
; (\lnot P(g(x),y) \lor P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
(define $p1
  {[#f {<Lit -1 t1> <Lit 1 t3>}]
   [#f {<Lit -1 t4>}]
   [#f {<Lit 1 t2>}]})

; Drinker's paradox
; 1. \lnot \exists x. D(x) \to \forall y. D(y)
; 2. \forall x. \exists y. D(x) \land \lnot D(y)
; 3. \forall x. D(x) \land \lnot D(c)
; 4. D(x) \land \lnot D(c)
(define $p2
  {[#f {<Lit 1 (pred "D" x)>}]
   [#f {<Lit -1 (pred "D" (app "c"))>}]})

; Recall the axioms of groups:
; (1) (x*y)*z = x*(y*z)
; (2) x*(x^-1)= 1
; (3) (x^-1)*x = 1
; (4) x*1 = x
; (5) 1*x = x
; It is known that (3) and (5) above are redundant, i.e., provable from other axioms. Let's prove this!

(define $p (app "*" $1 $2)) ; product
(define $i (app "i" $1))    ; inverse
(define $e (app "e"))
(define $e1 (app "e1"))
(define $e2 (app "e2"))

(define $x' (i x))
(define $y' (i y))
(define $z' (i z))
(define $w' (i w))

; (a) axioms of groups
; - p(p(x,y),z) = p(x,p(y,z))
; - p(x,i(x)) = e
; - p(x,e) = x
; (b) axioms of equality
; - x = x
; - \lnot (x = y) \lor (y = x)
; - \lnot (x = y) \lor lnot (y = z) \lor (x = z)
; - \lnot (x = y) \lnot (z = w) \lor (p(x,z) = p(y,w))
; - \lnot (x = y) \lor (i(x) = i(y))
; (c) (negation) of the goal
; - \lnot (p(i(e1),e1) = e) \lor \lnot (p(e,e2) = e2)

(define $axioms-of-groups
  {[#t {<Lit 1 (eql (p (p x y) z) (p x (p y z)))>}]
   [#t {<Lit 1 (eql (p x x') e)>}]
   [#t {<Lit 1 (eql (p x e) x)>}]
  })

(define $axioms-of-equality
  {[#t {<Lit  1 (eql x x)>}]
   [#t {<Lit -1 (eql x y)> <Lit 1 (eql y x)>}]
   [#t {<Lit -1 (eql x y)> <Lit -1 (eql y z)> <Lit 1 (eql x z)>}]
  })

(define $congruence-groups
  {[#t {<Lit -1 (eql x y)> <Lit -1 (eql z w)> <Lit 1 (eql (p x z) (p y w))>}]
   [#t {<Lit -1 (eql x y)> <Lit 1 (eql x' y')>}]
  })

(define $axioms-of-groups-complete
  {@axioms-of-groups
   [#t {<Lit 1 (eql (i (p y x)) (p x' y'))>}]
   [#t {<Lit 1 (eql (p y' (p y x)) x)>}]
   [#t {<Lit 1 (eql (p x' x) e)>}]
   [#t {<Lit 1 (eql (i e) e)>}]
   [#t {<Lit 1 (eql (i x') x)>}]
   [#t {<Lit 1 (eql (p e x) x)>}]
   [#t {<Lit 1 (eql (p x (p x' y)) y)>}]
  })

; (1) (2) (4) |= (5)
(define $p3
  {@axioms-of-groups
   ; (negation of) the goal: e * x = x
   [#f {<Lit -1 (eql (p e e1) e1)>}]
   })

; (1) (2) (4) |= (3)
(define $p4
  {@axioms-of-groups
   ; (negation of) the goal: x^-1 * x = e
   [#f {<Lit -1 (eql (p (i e2) e2) e)>}]
   })

(define $g1
  {@axioms-of-groups-complete
   ; i(x) * y * x * i(y) = e
   [#f {<Lit -1 (eql (p x' (p y (p x y'))) e)>}]
   })

; ==============================================================================

(define $p5
  ; Issac is a boy
  {[#t {<Lit 1 (pred "B" (app "i"))>}]
   ; Kate is a girl
   [#t {<Lit 1 (pred "G" (app "k"))>}]
   ; Joe's friends are all tall
   [#t {<Lit -1 (pred "F" (app "j") x)> <Lit 1 (pred "T" x)>}]
   ; Harry loves any girl that is tall
   [#t {<Lit -1 (pred "G" y)> <Lit -1 (pred "T" y)> <Lit 1 (pred "L" (app "h") y)>}]
   ; Issac is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "i"))>}]
   ; Kate is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "k"))>}]

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   [#f {<Lit -1 (pred "L" (app "h") z)> <Lit -1 (pred "F" (app "j") z)>}]
  })

(define $p6
   ; Kate is a girl
  {[#t {<Lit 1 (pred "G" (app "k"))>}]
   ; Joe's friends are all tall
   [#t {<Lit -1 (pred "F" (app "j") x)> <Lit 1 (pred "T" x)>}]
   ; Harry loves any girl that is tall
   [#t {<Lit -1 (pred "G" y)> <Lit -1 (pred "T" y)> <Lit 1 (pred "L" (app "h") y)>}]
   ; Kate is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "k"))>}]

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   [#f {<Lit -1 (pred "L" (app "h") z)> <Lit -1 (pred "F" (app "j") z)>}]
   })

; ==============================================================================

(define $axioms-of-nat
   ; O + x = x
  {[#t {<Lit 1 (eql (app "+" (app "O") x) x)>}]
   ; S(m) + n = m + S(n)
   [#t {<Lit 1 (eql (app "+" (app "S" x) y)
                    (app "+" x (app "S" y)))>}]
   })

(define $zero  (app "O"))
(define $one   (app "S" (app "O")))
(define $two   (app "S" (app "S" (app "O"))))
(define $three (app "S" (app "S" (app "S" (app "O")))))
(define $four  (app "S" (app "S" (app "S" (app "S" (app "O"))))))

(define $p7
  {@axioms-of-nat
   ; S(O) + S(S(O)) = S(S(S(O)))
   [#f {<Lit -1 (eql (app "+" one two) three)>}]
   })

(define $p8
  {@axioms-of-nat
   ; O + S(S(O)) = S(S(O))
   [#f {<Lit -1 (eql (app "+" zero two) two)>}]
   })

(define $p9
  {[#f {<Lit -1 (eql x x)>}]})
