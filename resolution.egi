; Implementation of resolution principle for first-order logic in Egison

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     ; 関数適用
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (unify t s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $prop
  (matcher
     ; 述語
    {[<pred $ $> [string (list term)]
       {[<Pred $p $a> {[p a]}]
        [_ {}]}]
     [<equation $ $> [term term]
      {[<Equation $l $r> {[l r] [r l]}] ; unordered-pairのように
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (punify t s)]}]
     [<subterm $> term
      {[$s (psubterm s)]}]
     [$ something
       {[$tgt {tgt}]}]}))

;; term -> {term}
(define $subterm
  (lambda [$t]
    (concat
      (match-all t term
        {[<compound _ $xs> {@xs @(concat (map subterm xs))}]
         [_ {t}] ; var
        }))))

(define $psubterm
  (lambda [$p]
    (unique (concat
      (match-all p prop
        {[<pred _ <join _ <cons $x _>>> (subterm x)]
         [<equation $l $r> {@(subterm l) @(subterm r)}]
        })))))

(define $var (lambda $n <Var n>))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs>
        <Compound x xs>]})))

(define $pred
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs>
        <Pred x xs>]})))

(define $eql (lambda [$x $y] <Equation x y>))

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>
       )))

(define $fv
  (match-all-lambda term
    {[(occur $v) v]}))

(define $tsubst
  (match-lambda [something term]
    {[[$u <var $n>]
       (match u (multiset [integer term])
         {[<cons [,n $t] _> t] ; subst規則があればsubst
          [_ <Var n>]})]       ; なければそのまま
     [[$u <compound $f $xs>]
       <Compound f (map (lambda $x (tsubst u x)) xs)>]}))

(define $psubst
  (match-lambda [something prop]
    {[[$u <pred $p $xs>]
       <Pred p (map (lambda $x (tsubst u x)) xs)>]
     [[$u <equation $l $r>]
       <Equation (tsubst u l) (tsubst u r)>]}))

(define $csubst
  (match-all-lambda [something (multiset literal)]
    {[[$u <cons <lit $p $t> _>]
      <Lit p (psubst u t)>]}))

(define $replace-term
  (lambda [$s $t $tm]
    (match tm term
      {[,s t]
       [<var _> tm]
       [<compound $f $xs>
          <Compound f (map (lambda [$x] (replace-term s t x)) xs)>]
      })))

; (term, term) -> prop -> prop
(define $replace
  (lambda [$s $t $p]
    (match p prop
      {[<pred $f $xs> <Pred f (map (lambda [$x] (replace-term s t x)) xs)>]
       [<equation $l $r> <Equation (replace-term s t l) (replace-term s t r)>]
       })))

(assert-equal "csubst"
  (csubst {[y <Var x>] [x <Var z>]} {<Lit 1 (eql (var x) (var y))>})
  {<Lit 1 (var z) (var x)>})

; 失敗なら{}、成功なら{単一化子}を返す(optional型の気持ち)
(define $unify
  (match-lambda (unordered-pair term)
    {[<pair <var $x> <var ,x>>
      {{}}] ; 成功(空の代入を返す)
     [<pair <var $x> (& $t !(occur ,x))> ; 自由出現しない場合
      {{[x t]}}] ; 代入[t/x]を返す
     [<pair <compound $f <nil>> <compound ,f <nil>>>
      {{}}] ; 成功
     [<pair <compound $f <cons $x $xs>> <compound ,f <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} {}] ; unifyがすでに失敗している
        [<cons $u1 <nil>> ; unifiableな場合、単一化子をsingletonから取り出す
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} {}] ; 失敗
           [<cons $u2 <nil>> {{@u1 @u2}}]})]})] ; {@u1 @u2}はu1 ++ u2
     [_ {}]}))

(define $punify
  (match-lambda (unordered-pair prop)
    {[<pair <pred $p <nil>> <pred ,p <nil>>>
      {{}}]
     [<pair <pred $p <cons $x $xs>> <pred ,p <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} {}]
        [<cons $u1 <nil>>
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} {}] ; 失敗
           [<cons $u2 <nil>> {{@u1 @u2}}]})]})]
     [_ {}]
     ; [<pair <equation $xl $xr> <equation $yl $yr>>
     ;  (match (unify xl yl) (list something)
     ;   {[,{} {}]
     ;    [<cons $u1 <nil>>
     ;     (match (unify (subst u1 xr) (subst u1 yr)) (list something)
     ;      {[,{} {}]
     ;       [<cons $u2 <nil>> {{@u1 @u2}}]})]})]
    }))

(define $literal
  (algebraic-data-matcher
    ; intergerは1ならそのまま、-1ならnegateされる
    {<lit integer prop>}))

(define $fv-clause
  (lambda [$x]
    (unique (match-all x (multiset literal)
             {[<cons <lit _ <pred _
                              <join _ <cons (occur $v) _>>>> _> v]
              [<cons <lit _ <equation (occur $v) _>> _> v]}))))

(assert-equal "fv-clause-eq"
  (fv-clause {<Lit 1 (eql (var x) (var y))> <Lit 1 (pred "P" (var z) (var w))>})
  {(var x) (var y) (var z) (var w)})

(define $resolution
  (match-all-lambda (multiset (multiset literal))
     ; match equation
    {[<cons <cons <lit ,1 <equation $s $t>> $xs>
       <cons <cons <lit $not (& <subterm (& <unify ,s $sigma> $s')> $p)> $ys>
         _>>
      ; (io (do
      ;   {[(print (append-strings
      ;         {(show-term s') " <- " (show-term s) " = " (show-term t)}))]
      ;    [(print (show-prop p))]
      ;    ; [(print (show sigma))]
      ;    [(print (show-clause (csubst sigma {@xs @ys <Lit not p>})))]
      ;   }))
      (csubst sigma {@xs @ys <Lit not (replace s' t p)>})
     ]
     ; match predicate
     [<cons <cons <lit ,1 $t> $xs>
       <cons <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
         _>>
      (csubst sigma {@xs @ys})
     ]
     }))

; (io (do
;   {[(print (append-strings {(show-term t) " & ~" (show-term s)}))]
;    [(print (show sigma))]
;    [(print (show-clause {@(csubst sigma xs) @(csubst sigma ys)}))]
;   }
;   (return {@(csubst sigma xs) @(csubst sigma ys)}
;   )))

; objective
(assert-equal "resolution-eq"
  (resolution
    {{<Lit -1 (eql (var x) (var y))> <Lit 1 (var y)>}
     {<Lit 1  (eql (app "+" one two) three)>}})
  {{<Lit 1 three>} {<Lit 1 (app "+" one two)>}})

; positive resolution
(define $presolution
  (match-all-lambda (multiset (multiset literal))
     ; match equation
    {[<cons <cons <lit ,1 <equation $s $t>> $xs>
       <cons <cons <lit $not (& <subterm (& <unify ,s $sigma> $s')> $p)> $ys>
         _>>
      (csubst sigma {@xs @ys <Lit not (replace s' t p)>})]
     [<cons
        (& !<cons <lit ,-1 _> _> <cons <lit ,1 $t> $xs>)
        <cons
          <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
            _>>
       (csubst sigma {@xs @ys})
     ]}))

; 束縛変数の名前が各節で異なるようにする
(define $rename-problem
  (match-lambda [integer (list (list literal))]
    {[[$n <nil>]
      {}]
     [[$n <cons $c $cs>]
      (let {[$u (zip (fv-clause c)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (csubst u c)
              (rename-problem (+ n (length u)) cs)))]}))

(define $trivial?
  (lambda [$cls]
    (any id
      (match-all cls (multiset literal)
        {[<cons <lit ,1 $t> <cons <lit ,-1 ,t> _>> #t]
         [_ #f]}))))

(define $filter-clause
  (lambda [$clss]
    (filter (lambda [$cls] (not (trivial? cls))) clss)))

(define $unique-clause
  (match-all-lambda (list (multiset eq))
    [<join _ <cons $z !<join _ <cons ,z _>>>> z]))

(define $trim-clause
  (lambda [$clss]
    (filter-clause (unique-clause clss))))

(define $solve
  (match-lambda (multiset (multiset literal))
     ; empty clause
    {[<cons <nil> _>
      <REFUTE>]
     ; non-reflexive equation
     [<cons <cons <lit ,-1 <equation $s ,s>> _> _>
      <REFUTE>]
     [$p
      (let {[$q (resolution (rename-problem 0 p))]}
        (if (include?/m (multiset literal) p q) ; q \subseteq? p
          <SATURATED>
          (let {[$r (trim-clause {@p @q})]}
            (solve (debug-c r)))))]}))

; positive closure
(define $psolve
  (match-lambda (multiset (multiset literal))
     ; empty clause
    {[<cons <nil> _>
      <REFUTE>]
     ; non-reflexive equation
     [<cons <cons <lit ,-1 <equation $s ,s>> _> _>
      <REFUTE>]
     [$p
      (let {[$q (presolution (rename-problem 0 p))]}
        (if (include?/m (multiset literal) p q) ; q \subseteq? p
          <SATURATED>
          (let {[$r (trim-clause {@p @q})]}
            (psolve (debug-c r)))))]}))
