; Implementation of resolution principle for first-order logic in Egison

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     ; 関数適用または述語適用
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     ; 等式
     [<eq $ $> [term term]
      {[<Eq $l $r> {[l r] [r l]}] ; unordered-pairのように
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (unify t s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

; (define $prop
;   (matcher
;     {[<pred $ $> [string (list term)]
;        {[<Pred $p $a> {[p a]}]
;         [_ {}]}]
;      [<eq $ $> [term term]
;        {[<Eq $l $r> {[l r]}]
;         [_ {}]}]
;      ; 要りそう
;      [<unify ,$t $> something
;        {[$s (unify t s)]}]
;      [$ something
;        {[$tgt {tgt}]}]}))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs>
        <Compound x xs>]})))

(define $eql (lambda [$x $y] <Eq x y>))

(define $var
  (lambda $n
    <Var n>))

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>
       <eq (occur v) _>
       <eq _ (occur v)>)))

(define $fv
  (match-all-lambda term
    {[(occur $v) v]}))

(define $subst
  (lambda [$u $t]
    (match t term
      {[<var $n>
         (match u (multiset [integer term])
           {[<cons [,n $t] _> t] ; subst規則があればsubst
            [_ <Var n>]})]       ; なければそのまま
       [<compound $f $xs>
         <Compound f (map (lambda $x (subst u x)) xs)>]
       [<eq $l $r>
         <Eq (subst u l) (subst u r)>]})))

; 失敗なら{}、成功なら{単一化子}を返す(optional型の気持ち)
(define $unify
  (match-lambda (unordered-pair term)
    {[<pair <var $x> <var ,x>>
      {{}}] ; 成功(空の代入を返す)
     [<pair <var $x> (& $t !(occur ,x))> ; 自由出現しない場合
      {{[x t]}}] ; 代入[t/x]を返す
     [<pair <compound $f <nil>> <compound ,f <nil>>>
      {{}}] ; 成功
     [<pair <compound $f <cons $x $xs>> <compound ,f <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} {}] ; unifyがすでに失敗している
        [<cons $u1 <nil>> ; unifiableな場合、単一化子をsingletonから取り出す
         (match (unify (subst u1 <Compound f xs>) (subst u1 <Compound f ys>))
                (list something)
          {[,{} {}] ; 失敗
           [<cons $u2 <nil>> {{@u1 @u2}}]})]})] ; {@u1 @u2}はu1 ++ u2
     [<pair <eq $xl $xr> <eq $yl $yr>>
      (match (unify xl yl) (list something)
       {[,{} {}] ; unifyがすでに失敗している
        [<cons $u1 <nil>> ; unifiableな場合、単一化子u1をsingletonから取り出す
         (match (unify xr yr) (list something)
          {[,{} {}]
           [<cons $u2 <nil>> {@u1 @u2}]})]})]
     [_ {}]}))

(define $literal
  (algebraic-data-matcher
    ; intergerは1ならそのまま、-1ならnegateされる
    {<lit integer term>}))

(define $fv-clause
  (lambda [$x]
    (unique (match-all x (multiset literal)
      [<cons <lit _ (occur $v)> _> v]))))

(define $subst-clause
  (match-all-lambda [something (multiset literal)]
    {[[$u <cons <lit $p $t> _>]
      <Lit p (subst u t)>]}))

(define $resolution
  (match-all-lambda (multiset (multiset literal))
    {[<cons <cons <lit ,1 $t> $xs>
       <cons <cons <lit ,-1 (& <unify ,t $σ> $s)> $ys>
         _>>
      {@(subst-clause σ xs) @(subst-clause σ ys)}]}))

; positive resolution
(define $presolution
  (match-all-lambda (multiset (multiset literal))
   {[<cons
       (& !<cons <lit ,-1 _> _> <cons <lit ,1 $t> $xs>)
       <cons
         <cons <lit ,-1 (& <unify ,t $σ> $s)> $ys>
           _>>
       {@(subst-clause σ xs) @(subst-clause σ ys)}]}))

; 束縛変数の名前が各節で異なるようにする
(define $rename-problem
  (match-lambda [integer (list (list literal))]
    {[[$n <nil>]
      {}]
     [[$n <cons $c $cs>]
      (let {[$u (zip (fv-clause c)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (subst-clause u c)
              (rename-problem (+ n (length u)) cs)))]}))

(define $trivial?
  (lambda [$cls]
    (any id
      (match-all cls (multiset literal)
        {[<cons <lit ,1 $t> <cons <lit ,-1 ,t> _>> #t]
         [_ #f]}))))

(define $filter-clause
  (lambda [$clss]
    (filter (lambda [$cls] (not (trivial? cls))) clss)))

(define $unique
  (match-all-lambda (list eq)
    [<join _ <cons $z !<join _ <cons ,z _>>>> z]))

(define $trim-clause
  (lambda [$clss]
    (filter-clause
      (match-all clss (list (multiset eq))
        [<join _ <cons $z !<join _ <cons ,z _>>>> z]))))

(define $solve
  (match-lambda (multiset (multiset literal))
    {[<cons <nil> _> ; 空節が導出できた
      <REFUTE>]
     [$p
      (let {[$q (resolution (rename-problem 0 p))]}
        (if (include?/m (multiset literal) p q) ; q \subseteq? p
          <SATURATED>
          (let {[$r (trim-clause {@p @q})]}
            (solve (debug-c r)))))]}))

; positive closure
(define $psolve
  (match-lambda (multiset (multiset literal))
    {[<cons <nil> _> ; 空節が導出できた
      <REFUTE>]
     [$p
      (let {[$q (presolution (rename-problem 0 p))]}
        (if (include?/m (multiset literal) p q) ; q \subseteq? p
          <SATURATED>
          (let {[$r (trim-clause {@p @q})]}
            (psolve (debug-c r)))))]}))
