; Implementation of resolution principle for first-order logic in Egison

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     ; 関数適用
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (unify t s)]}]
     [<subterm $ $> [term something]
      {[$s (subterm s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $prop
  (matcher
     ; 述語
    {[<pred $ $> [string (list term)]
       {[<Pred $p $a> {[p a]}]
        [_ {}]}]
     [<equation $ $> [term term]
      {[<Equation $l $r> {[l r] [r l]}] ; unordered-pairのように
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (punify t s)]}]
     [<subterm $ $> [term something]
      {[$s (psubterm s)]}]
     [$ something
       {[$tgt {tgt}]}]}))

;; term -> {term, term -> term}
(define $subterm
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm $x $env> $xs'>>>
       (let {[$env' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose env' env)])]
     [$t [t id]]}))

;; prop -> {term, term -> prop}
(define $psubterm
  (match-all-lambda p prop
    {[<pred $f <join $xs <cons <subterm $x $env> $xs'>>>
       [x (lambda [$x] <Pred f (append xs (cons (env x) xs'))>)]]
     [<equation <subterm $x $env> $r>
       [x (lambda [$x] <Equation (env x) r>)]]
    }))

(assert-equal "subterm"
  ; x = (y + (z * w))
  (match-all (eql (var x) (app "+" (var y) (app "*" (var z) (var w)))) prop
    {[<subterm (& !<var _> $a) $env> [a (env (var 4))]]})
  {[(app "*" (var z) (var w)) (eql (var x) (app "+" (var y) (var 4)))]
   [(app "+" (var y) (app "*" (var z) (var w))) (eql (var x) (var 4))]})

(define $var (lambda $n <Var n>))
(define $bottom (var -1))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs>
        <Compound x xs>]})))

(define $pred
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs>
        <Pred x xs>]})))

(define $eql (lambda [$x $y] <Equation x y>))

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>
       )))

(define $fv
  (match-all-lambda term
    {[(occur $v) v]}))

(define $tsubst
  (match-lambda [something term]
    {[[$u <var $n>]
       (match u (multiset [integer term])
         {[<cons [,n $t] _> t] ; subst規則があればsubst
          [_ <Var n>]})]       ; なければそのまま
     [[$u <compound $f $xs>]
       <Compound f (map (tsubst u $1) xs)>]}))

(define $psubst
  (match-lambda [something prop]
    {[[$u <pred $p $xs>]
       <Pred p (map (tsubst u $1) xs)>]
     [[$u <equation $l $r>]
       <Equation (tsubst u l) (tsubst u r)>]}))

(define $lsubst
  (match-lambda [something literal]
    {[[$u <lit $sign $p>]
        <Lit sign (psubst u p)>]}))

(define $csubst
  (match-all-lambda [something (multiset literal)]
    {[[$u <cons <lit $p $t> _>]
      <Lit p (psubst u t)>]}))

(assert-equal "csubst"
  (csubst {[y <Var x>] [x <Var z>]} {<Lit 1 (eql (var x) (var y))>})
  {<Lit 1 (var z) (var x)>})

; 失敗なら{}、成功なら{単一化子}を返す(optional型の気持ち)
(define $unify
  (match-lambda (unordered-pair term)
    {[<pair <var $x> <var ,x>>
      {{}}] ; 成功(空の代入を返す)
     [<pair <var $x> (& $t !(occur ,x))> ; 自由出現しない場合
      {{[x t]}}] ; 代入[t/x]を返す
     [<pair <compound $f <nil>> <compound ,f <nil>>>
      {{}}] ; 成功
     [<pair <compound $f <cons $x $xs>> <compound ,f <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} {}] ; unifyがすでに失敗している
        [<cons $u1 <nil>> ; unifiableな場合、単一化子をsingletonから取り出す
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} {}] ; 失敗
           [<cons $u2 <nil>> {{@u1 @u2}}]})]})] ; {@u1 @u2}はu1 ++ u2
     [_ {}]}))

(define $punify
  (match-lambda (unordered-pair prop)
    {[<pair <pred $p <nil>> <pred ,p <nil>>>
      {{}}]
     [<pair <pred $p <cons $x $xs>> <pred ,p <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} {}]
        [<cons $u1 <nil>>
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} {}] ; 失敗
           [<cons $u2 <nil>> {{@u1 @u2}}]})]})]
     [_ {}]
     ; [<pair <equation $xl $xr> <equation $yl $yr>>
     ;  (match (unify xl yl) (list something)
     ;   {[,{} {}]
     ;    [<cons $u1 <nil>>
     ;     (match (unify (subst u1 xr) (subst u1 yr)) (list something)
     ;      {[,{} {}]
     ;       [<cons $u2 <nil>> {{@u1 @u2}}]})]})]
    }))

(define $literal
  (algebraic-data-matcher
    ; intergerは1ならそのまま、-1ならnegateされる
    {<lit integer prop>}))

(define $fv-clause
  (lambda [$x]
    (unique (match-all x (multiset literal)
             {[<cons <lit _ <pred _
                              <join _ <cons (occur $v) _>>>> _> v]
              [<cons <lit _ <equation (occur $v) _>> _> v]}))))

(assert-equal "fv-clause-eq"
  (fv-clause {<Lit 1 (eql (var x) (var y))> <Lit 1 (pred "P" (var z) (var w))>})
  {(var x) (var y) (var z) (var w)})

; ================================== LPO =======================================

; assumes that the two input lists have the same length
(define $lpo?
  (match-lambda [(list term) (list term)]
    {[[<cons $s $sx> <cons ,s $tx>]
        (lpo? sx tx)]
     [[<cons $s _> <cons ?(succ? s $) _>] #t]
     [_ #f]}))

(define $terminate?
  (lambda [$x $ts]
    (all (succ? x $) ts)))

(define $weight
  (match-lambda string
    {[,"O" 0]
     [,"S" 1]
     [,"+" 2]
     [,"e" 1]
     [,"e1" 1]
     [,"e2" 1]
     [,"*" 3]
     [,"i" 4]}))

(define $sigord
  (lambda [$f $g]
    (gt? (weight f) (weight g))))

; Lexicographic Path Order
(define $ord-t
  (lambda [$x $y]
    (match [x y] [term term]
      {[[_ ,x] <Equal>]
       [[,bottom _] <Less>]
       [[_ ,bottom] <Greater>]
       [(| [<compound $f $ss>
            <compound ,f
              (& ?(lpo? ss $) ?(terminate? x $))>]
           [<compound _ <join _ <cons ,y _>>>
            _]
           [<compound _ <join _ <cons $s _>>>
            ?(succ? s $)]
           [<compound $f _>
            <compound ?(sigord f $) ?(terminate? x $)>])
          <Greater>]
       [(| [<compound $f
              (& (later ?(lpo? ss $)) ?(terminate? y $))>
            <compound ,f $ss>]
           [_
            <compound _ <join _ <cons ,x _>>>]
           [(later ?(succ? s $))
            <compound _ <join _ <cons $s _>>>]
           [<compound $f ?(terminate? y $)>
            <compound ?(sigord $ f) _>])
          <Less>]
       [_ <Undefined>]})))

(define $succ?
  (lambda [$x $y]
    (eq? (ord-t x y) <Greater>)))

(define $ord-mul
  (lambda [$ord]
    (lambda [$x $y]
      (compare-c/fn ord (reverse (sort/fn ord x))
                        (reverse (sort/fn ord y))))))

(define $ord-eq
  (match-lambda [prop prop]
    {[[<equation $s $t> <equation $p $q>]
        ((ord-mul ord-t) {s t} {p q})]}))

(define $convert-lit
  (match-lambda literal
    {[<lit ,1  <equation $s $t>> {{s} {t}}]
     [<lit ,-1 <equation $s $t>> {{s bottom} {t bottom}}]}))
(define $ord-lit
  (lambda [$l1 $l2]
    ((ord-mul (ord-mul ord-t)) (convert-lit l1) (convert-lit l2))))

(define $ord-cls
  (ord-mul ord-lit))

(assert-equal "ord-eq"
  (ord-eq (eql three two) (eql three one))
  <Greater>)
(assert-equal "ord-lit"
  (ord-lit <Lit 1 (eql three two)> <Lit -1 (eql three one)>)
  <Less>)

; (define $maximal-occur
;   (pattern-function [$p]
;     !<cons ?(eq? (ord-eq $ p) <Greater>) _>))
;
; (define $maximal-strict-occur
;   (pattern-function [$p]
;     !<cons (| ?(eq? (ord-eq $ p) <Greater>)
;               ?(eq? (ord-eq $ p) <Equal>)) _>))

; (define $reductive
;   (pattern-function [$s $t]
;     (& !(succ? t s)
;        !(eq? s t)
;        <maximal-strict-occur <Equation s t>>)))

; "closure sigma * {xs, s = t} is reductive for sigma * s = sigma * t"
(define $reductive?
  (lambda [$s $t $xs $sigma]
    (let {[$t' (tsubst sigma t)]
          [$s' (tsubst sigma s)]
          [$xs' (csubst sigma xs)]}
     (and (not (succ? t' s'))
          (neq? s' t')
          (maximal-strict-occur? <Lit 1 (eql s t)> xs sigma)))))

(assert-equal "reductive?1"
  (reductive? three two {<Lit 1 (eql three one)>} {})
  #t)
(assert-equal "reductive?2"
  (reductive? three two {<Lit -1 (eql three one)>} {})
  #f)

(define $maximal-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst sigma ls) (multiset literal)
        {[<cons ?(lambda [$x] (eq? (ord-lit x l') <Greater>)) _> #f]
         [_ #t]}))))

(define $maximal-strict-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst sigma ls) (multiset literal)
      {[<cons ?(lambda [$x] (eq? (ord-lit x l') <Greater>)) _> #f]
       [<cons ?(lambda [$x] (eq? (ord-lit x l') <Equal>)) _> #f]
       [_ #t]}))))

; =============================== resolution ===================================

; resolution + paramodulation
(define $resolution
  (match-all-lambda (multiset (multiset literal))
     ; match equation
    {[<cons <cons <lit ,1 <equation $s $t>> $xs>
       <cons <cons <lit $sign
           <subterm (& !<var _> <unify ,s $sigma> $s') $env>> $ys>
         _>>
      (csubst sigma {@xs @ys <Lit sign (env t)>})
     ]
     ; match predicate
     [<cons <cons <lit ,1 $t> $xs>
       <cons <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
         _>>
      (csubst sigma {@xs @ys})
     ]
     }))

; resolution + superposition
(define $sresolution
  (match-all-lambda (multiset (multiset literal))
    {; superposition left
     [(& <cons <cons <lit ,1 <equation $s $t>> $xs>
          <cons <cons <lit ,-1
             <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (neq? (ord-t (tsubst sigma v) (tsubst sigma u)) <Greater>)
                 (neq? (ord-t (tsubst sigma v) (tsubst sigma u)) <Equal>)
                 (maximal-occur? (eql u v) ys sigma))))
      (csubst sigma {@xs @ys <Lit -1 (eql (env t) v)>})
     ]

     ; superposition right
     [(& <cons <cons <lit ,1 <equation $s $t>> $xs>
          <cons <cons <lit ,1
             <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (reductive? u v ys sigma))))
      (csubst sigma {@xs @ys <Lit 1 (eql (env t) v)>})
     ]

     ; equality resolution
     [(& <cons <cons <lit ,-1 <equation $u (& <unify ,u $sigma> $v)>> $ys> _>
         ?(lambda [$z]
            (maximal-occur? (eql u v) ys sigma)))
      (csubst sigma ys)
     ]

     ; equality factoring
     [(& <cons <cons <lit ,1 <equation $s $t>>
               <cons <lit ,1 <equation (& <unify ,s $sigma> $s') $t'>> $xs>> _>
         ?(lambda [$z]
            (and (neq? (ord-t (tsubst sigma t ) (tsubst sigma s )) <Greater>)
                 (neq? (ord-t (tsubst sigma t') (tsubst sigma s')) <Greater>)
                 (maximal-occur? (eql s t) {(eql s' t') @xs} sigma))))
      (csubst sigma {<Lit -1 (eql t t')> <Lit 1 (eql s' t')> @xs})
     ]

     ; match predicate
     ; [<cons <cons <lit ,1 $t> $xs>
     ;   <cons <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
     ;     _>>
     ;  (csubst sigma {@xs @ys})
     ; ]
     }))

; positive resolution + paramodulation
(define $presolution
  (match-all-lambda (multiset (multiset literal))
     ; match equation
    {[<cons <cons <lit ,1 <equation $s $t>> $xs>
       <cons <cons <lit $sign
           (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $p)> $ys>
         _>>
      (csubst sigma {@xs @ys <Lit sign (env t)>})]
     [<cons
        (& !<cons <lit ,-1 _> _> <cons <lit ,1 $t> $xs>)
        <cons
          <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
            _>>
       (csubst sigma {@xs @ys})
     ]}))

; (io (do
;   {[(print (append-strings {(show-term t) " & ~" (show-term s)}))]
;    [(print (show sigma))]
;    [(print (show-clause {@(csubst sigma xs) @(csubst sigma ys)}))]
;   }
;   (return {@(csubst sigma xs) @(csubst sigma ys)}
;   )))

; ==============================================================================

; 束縛変数の名前が各節で異なるようにする
(define $rename-problem
  (match-lambda [integer (list (list literal))]
    {[[$n <nil>]
      {}]
     [[$n <cons $c $cs>]
      (let {[$u (zip (fv-clause c)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (csubst u c)
              (rename-problem (+ n (length u)) cs)))]}))

(define $trim-clause
  (match-all-lambda (list (multiset literal))
    [<join _ <cons
      (& $z !<cons <lit ,1 $t> <cons <lit ,-1 ,t> _>>
         !<cons <lit ,1 <equation $s ,s>> _>)
       !<join _ <cons ,z _>> >> z]))

(define $make-solve
  (lambda [$resol]
   (match-lambda (multiset (multiset literal))
      ; empty clause
     {[<cons <nil> _>
       <REFUTE>]
      ; non-reflexive equation
      [<cons <cons <lit ,-1 <equation $s ,s>> _> _>
       <REFUTE>]
      [$p
       (let {[$q (resol (rename-problem 0 p))]}
         (if (include?/m (multiset literal) p q) ; q \subseteq? p
           <SATURATED>
           (let {[$r (trim-clause {@p @q})]}
             ((make-solve resol) (debug-c r)))))]})))

(define $solve  (make-solve resolution))
(define $psolve (make-solve presolution))
(define $ssolve (make-solve sresolution))
