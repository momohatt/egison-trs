; Implementation of resolution principle for first-order logic in Egison

(load-file "term.egi")

(define $prop
  (matcher
     ; 述語
    {[<pred $ $> [string (list term)]
       {[<Pred $p $a> {[p a]}]
        [_ {}]}]
     [<equation $ $> [term term]
      {[<Equation $l $r> {[l r] [r l]}] ; unordered-pairのように
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (match (punify t s) (maybe something)
            {[(just $sigma) {sigma}]
             [(nothing)     {}]
             })]}]
     [<subterm $ $> [term something]
      {[$s (psubterm s)]}]
     [$ something
       {[$tgt {tgt}]}]}))

(define $literal
  (algebraic-data-matcher
    ; intergerは1ならそのまま、-1ならnegateされる
    {<lit integer prop>}))

(define $clause
  ; #t -> axiom, #f -> target (non-axiom)
  [bool (multiset literal)])

(define $pred
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs> <Pred x xs>]})))

(define $eql (lambda [$x $y] <Equation x y>))

;; prop -> {term, term -> prop}
(define $psubterm
  (match-all-lambda prop
    {[<pred $f <join $xs <cons <subterm $x $context> $xs'>>>
       [x (lambda [$x] <Pred f (append xs (cons (context x) xs'))>)]]
     [<equation <subterm $x $context> $r>
       [x (lambda [$x] <Equation (context x) r>)]]
    }))

(define $occur-prop
  (pattern-function [$v]
    (| <pred _ <join _ <cons (occur v) _>>>
       <equation (occur v) _>)))

; (define $pfv
;   (match-all-lambda prop
;     [(occur-prop $v) v]))

(define $cfv
  (lambda [$x]
    (unique (match-all x clause
              [[_ <cons <lit _ (occur-prop $v)>_ >] v]))))

(define $psubst
  (match-lambda [something prop]
    {[[$u <pred $p $xs>]
       <Pred p (map (tsubst u $1) xs)>]
     [[$u <equation $l $r>]
       <Equation (tsubst u l) (tsubst u r)>]}))

(define $lsubst
  (match-lambda [something literal]
    {[[$u <lit $sign $p>]
        <Lit sign (psubst u p)>]}))

(define $csubst'
  (match-all-lambda [something (multiset literal)]
    [[$u <cons <lit $p $t> _>] <Lit p (psubst u t)>]))
(define $csubst
  (match-lambda [something clause]
    {[[$u [$b $ls]] [b (csubst' u ls)]]}))

; unify propositions (only predicates)
(define $punify
  (match-lambda (unordered-pair prop)
    {[<pair <pred $p <nil>> <pred ,p <nil>>>
      (Just {})]
     [<pair <pred $p <cons $x $xs>> <pred ,p <cons $y $ys>>>
      (match (unify x y) (maybe something)
       {[(nothing) Nothing]
        [(just $u1)
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (maybe something)
          {[(nothing) Nothing] ; 失敗
           [(just $u2) (Just {@u1 @u2})]})]})]
     [_ Nothing]
    }))

; ================================ ordering ====================================

(define $ord-mul
  (lambda [$ord]
    (lambda [$x $y]
      (compare-c/fn ord (reverse (sort/fn ord x))
                        (reverse (sort/fn ord y))))))

(define $ord-eq
  (match-lambda [prop prop]
    {[[<equation $s $t> <equation $p $q>]
        ((ord-mul ord-t) {s t} {p q})]}))

(define $convert-lit
  (match-lambda literal
    {[<lit ,1  <equation $s $t>> {{s} {t}}]
     [<lit ,-1 <equation $s $t>> {{s bottom} {t bottom}}]}))
(define $ord-lit
  (lambda [$l1 $l2]
    ((ord-mul (ord-mul ord-t)) (convert-lit l1) (convert-lit l2))))

(define $ord-cls
  (lambda [$cls1 $cls2]
    ((ord-mul ord-lit) (snd cls1) (snd cls2))))

(assert-equal "ord-eq"
  (ord-eq (eql three two) (eql three one))
  <Greater>)
(assert-equal "ord-lit"
  (ord-lit <Lit 1 (eql three two)> <Lit -1 (eql three one)>)
  <Less>)

; "closure sigma * {xs, s = t} is reductive for sigma * s = sigma * t"
; xs is not clause but (multiset literal)
(define $reductive?
  (lambda [$s $t $xs $sigma]
    (let {[$t' (tsubst sigma t)]
          [$s' (tsubst sigma s)]
          [$xs' (csubst' sigma xs)]}
     (and (not (succ? t' s'))
          (neq? s' t')
          (maximal-strict-occur? <Lit 1 (eql s' t')> xs' sigma)))))

(assert-equal "reductive?1"
  (reductive? three two [#t {<Lit 1 (eql three one)>}] {})
  #t)
(assert-equal "reductive?2"
  (reductive? three two [#t {<Lit -1 (eql three one)>}] {})
  #f)

; ls is not clause but (multiset literal)
(define $maximal-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst' sigma ls) (multiset literal)
        {[<cons ?(lambda [$x] (gt?/fn ord-lit x l')) _> #f]
         [_ #t]}))))
(define $maximal-strict-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst' sigma ls) (multiset literal)
      {[<cons ?(lambda [$x] (geq?/fn ord-lit x l')) _> #f]
       [_ #t]}))))

; =============================== resolution ===================================

; resolution + paramodulation
(define $resolution
  (match-all-lambda (multiset clause)
     ; match equation
    {[<cons [_ <cons <lit ,1 <equation $s $t>> $xs>]
      <cons [,#f <cons <lit $sign
           <subterm (& !<var _> <unify ,s $sigma> $s') $env>> $ys>]
         _>>
      [#f (csubst' sigma {@xs @ys <Lit sign (env t)>})]
     ]
     ; match predicate
     [<cons [_ <cons <lit ,1 $t> $xs>]
      <cons [$b <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>]
         _>>
      [b (csubst' sigma {@xs @ys})]
     ]
     }))

; positive resolution + paramodulation
(define $presolution
  (match-all-lambda (multiset clause)
     ; match equation
    {[<cons [_ <cons <lit ,1 <equation $s $t>> $xs>]
      <cons [,#f <cons <lit $sign
           <subterm (& !<var _> <unify ,s $sigma> $s') $env>> $ys>]
         _>>
      [#f (csubst' sigma {@xs @ys <Lit sign (env t)>})]
     ]
     ; match predicate
     [<cons [_ <cons <lit ,1 $t> (& !<cons <lit ,-1 _> _> $xs)>]
      <cons [$b <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>]
         _>>
      [b (csubst' sigma {@xs @ys})]
     ]
     }))

; resolution + superposition
(define $sresolution
  (match-all-lambda (multiset clause)
     ; superposition left
    {[(& <cons [_  <cons <lit ,1 <equation $s $t>> $xs>]
         <cons [,#f <cons <lit ,-1
           <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>]
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (not (geq?/fn ord-t (tsubst sigma v) (tsubst sigma u)))
                 (maximal-occur? <Lit -1 (eql u v)> ys sigma))))
      [#f (csubst' sigma {@xs @ys <Lit -1 (eql (env t) v)>})]
     ]

     ; superposition right
     [(& <cons [_  <cons <lit ,1 <equation $s $t>> $xs>]
         <cons [,#f <cons <lit ,1
           <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>]
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (reductive? u v ys sigma))))
      [#f (csubst' sigma {@xs @ys <Lit 1 (eql (env t) v)>})]
     ]

     ; equality resolution
     [(& <cons [,#f <cons <lit ,-1 <equation $u (& <unify ,u $sigma> $v)>> $ys>] _>
         ?(lambda [$z]
            (maximal-occur? <Lit -1 (eql u v)> ys sigma)))
      [#f (csubst' sigma ys)]
     ]

     ; equality factoring
     [(& <cons
           [,#f <cons <lit ,1 <equation $s $t>>
                <cons <lit ,1 <equation (& <unify ,s $sigma> $s') $t'>> $xs>>] _>
         ?(lambda [$z]
            (and
              (not (gt?/fn ord-t (tsubst sigma t ) (tsubst sigma s )))
              (not (gt?/fn ord-t (tsubst sigma t') (tsubst sigma s')))
              (maximal-occur? <Lit 1 (eql s t)> {<Lit 1 (eql s' t')> @xs} sigma))))
      [#f (csubst sigma' {<Lit -1 (eql t t')> <Lit 1 (eql s' t')> @xs})]
     ]
     }))

; (io (do
;   {[(print (S.concat {(show-term t) " & ~" (show-term s)}))]
;    [(print (show sigma))]
;    [(print (show-clause {@(csubst sigma xs) @(csubst sigma ys)}))]
;   }
;   (return {@(csubst sigma xs) @(csubst sigma ys)}
;   )))

; ==============================================================================

; 束縛変数の名前が各節で異なるようにする
(define $rename-problem
  (match-lambda [integer (list clause)]
    {[[$n <nil>]
      {}]
     [[$n <cons $c $cs>]
      (let {[$u (zip (cfv c)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (csubst u c)
              (rename-problem (+ n (length u)) cs)))]}))

(define $trim-clause
  (match-all-lambda (list clause)
    [<join _ <cons
      (& $z
         ![_ <cons <lit ,1 $t> <cons <lit ,-1 ,t> _>>]
         ![_ <cons <lit ,1 <equation $s ,s>> _>])
       !<join _ <cons ,z _>> >> z]))

(define $make-solve
  (lambda [$resol]
   (match-lambda (multiset clause)
      ; empty clause
     {[<cons [_ <nil>] _>
       <REFUTE>]
      ; non-reflexive equation
      [<cons [_ <cons <lit ,-1 <equation $s ,s>> _>] _>
       <REFUTE>]
      [$p
       (let {[$q (resol (rename-problem 0 p))]}
         (if (include?/m clause p q) ; q \subseteq? p
           <SATURATED>
           (let {[$r (trim-clause {@p @q})]}
             ((make-solve resol) (debug/fn show-clauses r)))))]})))

(define $solve  (make-solve resolution))
(define $psolve (make-solve presolution))
(define $ssolve (make-solve sresolution))

;;==============================================================================

(define $show-prop
  (match-lambda prop
    {[<pred $f ,{}> f]
     [<pred $f $xs>
       (S.concat {f "(" (S.intercalate ", " (map show-term xs)) ")"})]
     [<equation $x $y>
       (S.concat {(show-term x) " = " (show-term y)})]
    }))

(define $show-lit
  (match-lambda literal
    {[<lit ,1  $t> (show-prop t)]
     [<lit ,-1 $t> (append-string "~" (show-prop t))]}))

(define $show-clause
  (match-lambda clause
    {[[_ $cls]
      (S.concat {"{" (S.intercalate ", " (map show-lit cls)) "}"})]
     }))

(define $show-clauses
  (col-show/fn show-clause $1))

;;==============================================================================

; P(g(x), y)
(define $t1 (pred "P" (app "g" x) y))
; P(g(g(c)), c)
(define $t2 (pred "P" (app "g" (app "g" c)) c))

(define $test-occur
  (lambda [$v $t]
    (match t term
      {[(occur ,v) #t]
       [_ #f]})))

(assert "occur1" (test-occur x t1))
(assert "occur2" (not (test-occur z t1)))

(assert "fv1"
  (match (pfv t1) (multiset integer)
    {[,{0 1} #t]
     [_ #f]}))
(assert-equal "cfv-eq"
  (cfv [#t {<Lit 1 (eql x y)> <Lit 1 (pred "P" z w)>}])
  {0 1 2 3})

(assert-equal "subterm1"
  ; x = (y + (z * w))
  (match-all (eql x (app "+" y (app "*" z w))) prop
    {[<subterm (& !<var _> $a) $env> [a (env (var 4))]]})
  {[(app "*" z w) (eql (app "+" y (var 4)) x)]
   [(app "+" y (app "*" z w)) (eql (var 4) x)]})

; [z / x, x / y] P(g(x), y) = P(g(z), x)
(assert-equal "subst1"
  (psubst {[1 x] [0 z]} t1)
  (pred "P" (app "g" z) x))

; [z / z] P(g(x), y) = P(g(x), y)
(assert-equal "subst2"
  (psubst {[2 z]} t1)
  (pred "P" (app "g" x) y))

(assert-equal "subst3"
  (psubst {[1 x] [0 z]}
    (eql (app "f" x) (app "+" y x)))
  (eql (app "f" z) (app "+" x z)))

(assert-equal "csubst1"
  (csubst {[1 x] [0 z]} [#t {<Lit 1 (eql x y)>}])
  [#t {<Lit 1 (eql z x)>}])
(assert-equal "csubst'1"
  (csubst' {[1 x] [0 z]} {<Lit 1 (eql x y)>})
  {<Lit 1 (eql z x)>})

; t1 = P(g(x), y)
; t2 = P(g(g(c)), c)
(assert-equal "unify1" (unify x x) {{}})
(assert-equal "unify2" (unify t1 z) {{[2 t1]}})
; {[x, g(c)], [y, c]}
(assert-equal "unify3"
  (punify t1 t2)
  {{[0 <Compound "g" {<Compound "c" {}>}>] [1 <Compound "c" {}>]}})

; ========================= example (group theory) =============================

(define $t3 (pred "P" x (app "f" x y)))
(define $t4 (pred "P" c y))

; 1. Problem:
; (\forall x y. \exists z. P(g(x),y) \to P(x,z))
; \land (\forall y. \lnot P(c,y)) \land P(g(g(c)),c)
; 2. Prenex normal form
; \forall x y. \exists z. (P(g(x),y) \to P(x,z))
; \land \lnot P(c,y) \land P(g(g(c)),c)
; 3. Skolemization
; \forall x y. (P(g(x),y) \to P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
; 4. Conjunction normal form
; (\lnot P(g(x),y) \lor P(x,f(x,y))) \land \lnot P(c,y) \land P(g(g(c)),c)
(define $p1
  {[#f {<Lit -1 t1> <Lit 1 t3>}]
   [#f {<Lit -1 t4>}]
   [#f {<Lit 1 t2>}]})

; Drinker's paradox
; 1. \lnot \exists x. D(x) \to \forall y. D(y)
; 2. \forall x. \exists y. D(x) \land \lnot D(y)
; 3. \forall x. D(x) \land \lnot D(c)
; 4. D(x) \land \lnot D(c)
(define $p2
  {[#f {<Lit 1 (pred "D" x)>}]
   [#f {<Lit -1 (pred "D" c)>}]})

; Recall the axioms of groups:
; (1) (x*y)*z = x*(y*z)
; (2) x*(x^-1)= 1
; (3) (x^-1)*x = 1
; (4) x*1 = x
; (5) 1*x = x
; It is known that (3) and (5) above are redundant, i.e., provable from other axioms. Let's prove this!

(define $p (app "*" $1 $2)) ; product
(define $i (app "i" $1))    ; inverse
(define $e (app "e"))
(define $a' (i a))
(define $b' (i b))
(define $c' (i c))
(define $d' (i d))

(define $x' (i x))
(define $y' (i y))
(define $z' (i z))
(define $w' (i w))

; (a) axioms of groups
; - p(p(x,y),z) = p(x,p(y,z))
; - p(x,i(x)) = e
; - p(x,e) = x
; (b) axioms of equality
; - x = x
; - \lnot (x = y) \lor (y = x)
; - \lnot (x = y) \lor lnot (y = z) \lor (x = z)
; - \lnot (x = y) \lnot (z = w) \lor (p(x,z) = p(y,w))
; - \lnot (x = y) \lor (i(x) = i(y))
; (c) (negation) of the goal
; - \lnot (p(i(a),a) = e) \lor \lnot (p(e,b) = b)

(define $axioms-of-groups
  {[#t {<Lit 1 (eql (p (p x y) z) (p x (p y z)))>}]
   [#t {<Lit 1 (eql (p x x') e)>}]
   [#t {<Lit 1 (eql (p x e) x)>}]
  })

(define $axioms-of-equality
  {[#t {<Lit  1 (eql x x)>}]
   [#t {<Lit -1 (eql x y)> <Lit 1 (eql y x)>}]
   [#t {<Lit -1 (eql x y)> <Lit -1 (eql y z)> <Lit 1 (eql x z)>}]
  })

(define $congruence-groups
  {[#t {<Lit -1 (eql x y)> <Lit -1 (eql z w)> <Lit 1 (eql (p x z) (p y w))>}]
   [#t {<Lit -1 (eql x y)> <Lit 1 (eql x' y')>}]
  })

(define $axioms-of-groups-complete
  {@axioms-of-groups
   [#t {<Lit 1 (eql (i (p y x)) (p x' y'))>}]
   [#t {<Lit 1 (eql (p y' (p y x)) x)>}]
   [#t {<Lit 1 (eql (p x' x) e)>}]
   [#t {<Lit 1 (eql (i e) e)>}]
   [#t {<Lit 1 (eql (i x') x)>}]
   [#t {<Lit 1 (eql (p e x) x)>}]
   [#t {<Lit 1 (eql (p x (p x' y)) y)>}]
  })

; (1) (2) (4) |= (5)
(define $p3
  {@axioms-of-groups
   ; (negation of) the goal: e * x = x
   [#f {<Lit -1 (eql (p e a) a)>}]
   })

; (1) (2) (4) |= (3)
(define $p4
  {@axioms-of-groups
   ; (negation of) the goal: x^-1 * x = e
   [#f {<Lit -1 (eql (p (i b) b) e)>}]
   })

; (a * a')'
(define $g1' (i (p a a')))
; (a * a')'
; -> e'
; -> e
(define $g1
  {@axioms-of-groups-complete
   [#f {<Lit -1 (eql e g1')>}]})

; (((b * c) * d)' * b)' * d'
(define $g2' (p (i (p (i (p (p b c) d)) b))
                (i d)))
; (((b * c) * d)' * b)' * d'
; -> (d' * (b * c)' * b)' * d'
; -> (d' * c' * b' * b)' * d'
; -> (d' * c' * e)' * d'
; -> (d' * c')' * d'
; -> c'' * d'' * d'
; -> c'' * d * d'
; -> c'' * e
; -> c * e
; -> c
(define $g2
  {@axioms-of-groups-complete
   [#f {<Lit -1 (eql c g2')>}]})

(define $g3' (p g1' g2'))
(define $g3
  {@axioms-of-groups-complete
   [#f {<Lit -1 (eql c g3')>}]})

; ==============================================================================

(define $p5
  ; Issac is a boy
  {[#t {<Lit 1 (pred "B" (app "i"))>}]
   ; Kate is a girl
   [#t {<Lit 1 (pred "G" (app "k"))>}]
   ; Joe's friends are all tall
   [#t {<Lit -1 (pred "F" (app "j") x)> <Lit 1 (pred "T" x)>}]
   ; Harry loves any girl that is tall
   [#t {<Lit -1 (pred "G" y)> <Lit -1 (pred "T" y)> <Lit 1 (pred "L" (app "h") y)>}]
   ; Issac is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "i"))>}]
   ; Kate is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "k"))>}]

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   [#f {<Lit -1 (pred "L" (app "h") z)> <Lit -1 (pred "F" (app "j") z)>}]
  })

(define $p6
   ; Kate is a girl
  {[#t {<Lit 1 (pred "G" (app "k"))>}]
   ; Joe's friends are all tall
   [#t {<Lit -1 (pred "F" (app "j") x)> <Lit 1 (pred "T" x)>}]
   ; Harry loves any girl that is tall
   [#t {<Lit -1 (pred "G" y)> <Lit -1 (pred "T" y)> <Lit 1 (pred "L" (app "h") y)>}]
   ; Kate is a friend of Joe
   [#t {<Lit 1 (pred "F" (app "j") (app "k"))>}]

   ; question: does Harry love any of Joe's friends? If he does, who does he love?
   [#f {<Lit -1 (pred "L" (app "h") z)> <Lit -1 (pred "F" (app "j") z)>}]
   })

; ==============================================================================

(define $axioms-of-nat
   ; O + x = x
  {[#t {<Lit 1 (eql (app "+" (app "O") x) x)>}]
   ; S(m) + n = m + S(n)
   [#t {<Lit 1 (eql (app "+" (app "S" x) y)
                    (app "+" x (app "S" y)))>}]
   })

(define $zero  (app "O"))
(define $one   (app "S" (app "O")))
(define $two   (app "S" (app "S" (app "O"))))
(define $three (app "S" (app "S" (app "S" (app "O")))))
(define $four  (app "S" (app "S" (app "S" (app "S" (app "O"))))))

(define $p7
  {@axioms-of-nat
   ; S(O) + S(S(O)) = S(S(S(O)))
   [#f {<Lit -1 (eql (app "+" one two) three)>}]
   })

(define $p8
  {@axioms-of-nat
   ; O + S(S(O)) = S(S(O))
   [#f {<Lit -1 (eql (app "+" zero two) two)>}]
   })

(define $p9
  {[#f {<Lit -1 (eql x x)>}]})
