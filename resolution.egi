; Implementation of resolution principle for first-order logic in Egison

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     ; 関数適用
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (match (unify t s) (maybe something)
            {[(just $sigma) {sigma}]
             [(nothing)     {}]
            })]}]
     [<subterm $ $> [term something]
      {[$s (subterm s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $prop
  (matcher
     ; 述語
    {[<pred $ $> [string (list term)]
       {[<Pred $p $a> {[p a]}]
        [_ {}]}]
     [<equation $ $> [term term]
      {[<Equation $l $r> {[l r] [r l]}] ; unordered-pairのように
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (punify t s)]}]
     [<subterm $ $> [term something]
      {[$s (psubterm s)]}]
     [$ something
       {[$tgt {tgt}]}]}))

(define $literal
  (algebraic-data-matcher
    ; intergerは1ならそのまま、-1ならnegateされる
    {<lit integer prop>}))

(define $clause
  ; #t -> axiom, #f -> target (non-axiom)
  [bool (multiset literal)])

(define $var (lambda $n <Var n>))
(define $bottom (var -1))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs> <Compound x xs>]})))

(define $pred
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs> <Pred x xs>]})))

(define $eql (lambda [$x $y] <Equation x y>))

;; term -> {term, term -> term}
(define $subterm
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm $x $env> $xs'>>>
       (let {[$env' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose env' env)])]
     [$t [t id]]}))

;; prop -> {term, term -> prop}
(define $psubterm
  (match-all-lambda prop
    {[<pred $f <join $xs <cons <subterm $x $env> $xs'>>>
       [x (lambda [$x] <Pred f (append xs (cons (env x) xs'))>)]]
     [<equation <subterm $x $env> $r>
       [x (lambda [$x] <Equation (env x) r>)]]
    }))

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>)))

(define $occur-prop
  (pattern-function [$v]
    (| <pred _ <join _ <cons (occur v) _>>>
       <equation (occur v) _>)))

; (define $fv
;   (match-all-lambda term
;     {[(occur $v) v]}))
; (define $pfv
;   (match-all-lambda prop
;     [(occur-prop $v) v]))

(define $cfv
  (lambda [$x]
    (unique (match-all x clause
              [[_ <cons <lit _ (occur-prop $v)>_ >] v]))))

(define $tsubst
  (match-lambda [something term]
    {[[$u <var $n>]
       (match u (multiset [integer term])
         {[<cons [,n $t] _> t] ; subst規則があればsubst
          [_ <Var n>]})]       ; なければそのまま
     [[$u <compound $f $xs>]
       <Compound f (map (tsubst u $1) xs)>]}))

(define $psubst
  (match-lambda [something prop]
    {[[$u <pred $p $xs>]
       <Pred p (map (tsubst u $1) xs)>]
     [[$u <equation $l $r>]
       <Equation (tsubst u l) (tsubst u r)>]}))

(define $lsubst
  (match-lambda [something literal]
    {[[$u <lit $sign $p>]
        <Lit sign (psubst u p)>]}))

(define $csubst'
  (match-all-lambda [something (multiset literal)]
    [[$u <cons <lit $p $t> _>] <Lit p (psubst u t)>]))
(define $csubst
  (match-lambda [something clause]
    {[[$u [$b $ls]] [b (csubst' u ls)]]}))

; 失敗なら{}、成功なら{単一化子}を返す(optional型の気持ち)
(define $unify
  (match-lambda (unordered-pair term)
    {[<pair <var $x> <var ,x>>
      (Just {})] ; 成功(空の代入を返す)
     [<pair <var $x> (& $t !(occur ,x))> ; 自由出現しない場合
      (Just {[x t]})] ; 代入[t/x]を返す
     [<pair <compound $f <nil>> <compound ,f <nil>>>
      (Just {})] ; 成功
     [<pair <compound $f <cons $x $xs>> <compound ,f <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} Nothing] ; unifyがすでに失敗している
        [<cons $u1 <nil>> ; unifiableな場合、単一化子をsingletonから取り出す
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} Nothing] ; 失敗
           [<cons $u2 <nil>> (Just {@u1 @u2})]})]})] ; {@u1 @u2}はu1 ++ u2
     [_ Nothing]}))

; unify propositions (only predicates)
(define $punify
  (match-lambda (unordered-pair prop)
    {[<pair <pred $p <nil>> <pred ,p <nil>>>
      (Just {})]
     [<pair <pred $p <cons $x $xs>> <pred ,p <cons $y $ys>>>
      (match (unify x y) (list something)
       {[,{} Nothing]
        [<cons $u1 <nil>>
         (match (unify (tsubst u1 <Compound f xs>) (tsubst u1 <Compound f ys>))
                (list something)
          {[,{} Nothing] ; 失敗
           [<cons $u2 <nil>> (Just {@u1 @u2})]})]})]
     [_ Nothing]
    }))

; ================================== LPO =======================================

; assumes that the two input lists have the same length
(define $lpo?
  (match-lambda [(list term) (list term)]
    {[[<cons $s $sx> <cons ,s $tx>]
        (lpo? sx tx)]
     [[<cons $s _> <cons ?(succ? s $) _>] #t]
     [_ #f]}))

(define $terminate?
  (lambda [$x $ts]
    (all (succ? x $) ts)))

(define $weight
  (match-lambda string
    {[,"O" 0]
     [,"S" 1]
     [,"+" 2]
     [,"e" 1]
     [,"e1" 1]
     [,"e2" 1]
     [,"e3" 1]
     [,"e4" 1]
     [,"*" 3]
     [,"i" 4]
     [_ (debug 0)]}))

(define $sigord
  (lambda [$f $g]
    (gt? (weight f) (weight g))))

; Lexicographic Path Order
(define $ord-t
  (lambda [$x $y]
    (match [x y] [term term]
      {[[_ ,x] <Equal>]
       [[,bottom _] <Less>]
       [[_ ,bottom] <Greater>]
       [(| [<compound $f $ss>
            <compound ,f
              (& ?(lpo? ss $) ?(terminate? x $))>]
           [<compound _ <join _ <cons ,y _>>>
            _]
           [<compound _ <join _ <cons $s _>>>
            ?(succ? s $)]
           [<compound $f _>
            <compound ?(sigord f $) ?(terminate? x $)>])
          <Greater>]
       [(| [<compound $f
              (& (later ?(lpo? ss $)) ?(terminate? y $))>
            <compound ,f $ss>]
           [_
            <compound _ <join _ <cons ,x _>>>]
           [(later ?(succ? s $))
            <compound _ <join _ <cons $s _>>>]
           [<compound $f ?(terminate? y $)>
            <compound ?(sigord $ f) _>])
          <Less>]
       [_ <Undefined>]})))

(define $succ?
  (lambda [$x $y]
    (eq? (ord-t x y) <Greater>)))

(define $ord-mul
  (lambda [$ord]
    (lambda [$x $y]
      (compare-c/fn ord (reverse (sort/fn ord x))
                        (reverse (sort/fn ord y))))))

(define $ord-eq
  (match-lambda [prop prop]
    {[[<equation $s $t> <equation $p $q>]
        ((ord-mul ord-t) {s t} {p q})]}))

(define $convert-lit
  (match-lambda literal
    {[<lit ,1  <equation $s $t>> {{s} {t}}]
     [<lit ,-1 <equation $s $t>> {{s bottom} {t bottom}}]}))
(define $ord-lit
  (lambda [$l1 $l2]
    ((ord-mul (ord-mul ord-t)) (convert-lit l1) (convert-lit l2))))

(define $ord-cls
  (lambda [$cls1 $cls2]
    ((ord-mul ord-lit) (snd cls1) (snd cls2))))

(assert-equal "ord-eq"
  (ord-eq (eql three two) (eql three one))
  <Greater>)
(assert-equal "ord-lit"
  (ord-lit <Lit 1 (eql three two)> <Lit -1 (eql three one)>)
  <Less>)

; (define $maximal-occur
;   (pattern-function [$p]
;     !<cons ?(eq? (ord-eq $ p) <Greater>) _>))
; (define $maximal-strict-occur
;   (pattern-function [$p]
;     !<cons (| ?(eq? (ord-eq $ p) <Greater>)
;               ?(eq? (ord-eq $ p) <Equal>)) _>))
; (define $reductive
;   (pattern-function [$s $t]
;     (& !(succ? t s)
;        !(eq? s t)
;        <maximal-strict-occur <Equation s t>>)))

; "closure sigma * {xs, s = t} is reductive for sigma * s = sigma * t"
; xs is not clause but (multiset literal)
(define $reductive?
  (lambda [$s $t $xs $sigma]
    (let {[$t' (tsubst sigma t)]
          [$s' (tsubst sigma s)]
          [$xs' (csubst' sigma xs)]}
     (and (not (succ? t' s'))
          (neq? s' t')
          (maximal-strict-occur? <Lit 1 (eql s' t')> xs' sigma)))))

(assert-equal "reductive?1"
  (reductive? three two [#t {<Lit 1 (eql three one)>}] {})
  #t)
(assert-equal "reductive?2"
  (reductive? three two [#t {<Lit -1 (eql three one)>}] {})
  #f)

; ls is not clause but (multiset literal)
(define $maximal-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst' sigma ls) (multiset literal)
        {[<cons ?(lambda [$x] (eq? (ord-lit x l') <Greater>)) _> #f]
         [_ #t]}))))
(define $maximal-strict-occur?
  (lambda [$l $ls $sigma]
    (let {[$l' (lsubst sigma l)]}
      (match (csubst' sigma ls) (multiset literal)
      {[<cons ?(lambda [$x] (eq? (ord-lit x l') <Greater>)) _> #f]
       [<cons ?(lambda [$x] (eq? (ord-lit x l') <Equal>)) _> #f]
       [_ #t]}))))

; =============================== resolution ===================================

; resolution + paramodulation
(define $resolution
  (match-all-lambda (multiset clause)
     ; match equation
    {[<cons [_ <cons <lit ,1 <equation $s $t>> $xs>]
      <cons [,#f <cons <lit $sign
           <subterm (& !<var _> <unify ,s $sigma> $s') $env>> $ys>]
         _>>
      [#f (csubst' sigma {@xs @ys <Lit sign (env t)>})]
     ]
     ; match predicate
     [<cons [_ <cons <lit ,1 $t> $xs>]
      <cons [$b <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>]
         _>>
      [b (csubst' sigma {@xs @ys})]
     ]
     }))

; positive resolution + paramodulation
(define $presolution
  (match-all-lambda (multiset clause)
     ; match equation
    {[<cons [_ <cons <lit ,1 <equation $s $t>> $xs>]
      <cons [,#f <cons <lit $sign
           <subterm (& !<var _> <unify ,s $sigma> $s') $env>> $ys>]
         _>>
      [#f (csubst' sigma {@xs @ys <Lit sign (env t)>})]
     ]
     ; match predicate
     [<cons [_ <cons <lit ,1 $t> (& !<cons <lit ,-1 _> _> $xs)>]
      <cons [$b <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>]
         _>>
      [b (csubst' sigma {@xs @ys})]
     ]
     }))

; resolution + superposition
(define $sresolution
  (match-all-lambda (multiset clause)
     ; superposition left
    {[(& <cons [_  <cons <lit ,1 <equation $s $t>> $xs>]
         <cons [,#f <cons <lit ,-1
           <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>]
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (neq? (ord-t (tsubst sigma v) (tsubst sigma u)) <Greater>)
                 (neq? (ord-t (tsubst sigma v) (tsubst sigma u)) <Equal>)
                 (maximal-occur? <Lit -1 (eql u v)> ys sigma))))
      [#f (csubst' sigma {@xs @ys <Lit -1 (eql (env t) v)>})]
     ]

     ; superposition right
     [(& <cons [_  <cons <lit ,1 <equation $s $t>> $xs>]
         <cons [,#f <cons <lit ,1
           <equation (& <subterm (& !<var _> <unify ,s $sigma> $s') $env> $u) $v>>
             $ys>]
            _>>
         ?(lambda [$z] ; z does not occur
            (and (reductive? s t xs sigma)
                 (reductive? u v ys sigma))))
      [#f (csubst' sigma {@xs @ys <Lit 1 (eql (env t) v)>})]
     ]

     ; equality resolution
     [(& <cons [,#f <cons <lit ,-1 <equation $u (& <unify ,u $sigma> $v)>> $ys>] _>
         ?(lambda [$z]
            (maximal-occur? <Lit -1 (eql u v)> ys sigma)))
      [#f (csubst' sigma ys)]
     ]

     ; equality factoring
     [(& <cons
           [,#f <cons <lit ,1 <equation $s $t>>
                <cons <lit ,1 <equation (& <unify ,s $sigma> $s') $t'>> $xs>>] _>
         ?(lambda [$z]
            (and
              (neq? (ord-t (tsubst sigma t ) (tsubst sigma s )) <Greater>)
              (neq? (ord-t (tsubst sigma t') (tsubst sigma s')) <Greater>)
              (maximal-occur? <Lit 1 (eql s t)> {<Lit 1 (eql s' t')> @xs} sigma))))
      [#f (csubst sigma' {<Lit -1 (eql t t')> <Lit 1 (eql s' t')> @xs})]
     ]
     }))

; (io (do
;   {[(print (append-strings {(show-term t) " & ~" (show-term s)}))]
;    [(print (show sigma))]
;    [(print (show-clause {@(csubst sigma xs) @(csubst sigma ys)}))]
;   }
;   (return {@(csubst sigma xs) @(csubst sigma ys)}
;   )))

; ==============================================================================

; 束縛変数の名前が各節で異なるようにする
(define $rename-problem
  (match-lambda [integer (list clause)]
    {[[$n <nil>]
      {}]
     [[$n <cons $c $cs>]
      (let {[$u (zip (cfv c)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (csubst u c)
              (rename-problem (+ n (length u)) cs)))]}))

(define $trim-clause
  (match-all-lambda (list clause)
    [<join _ <cons
      (& $z
         ![_ <cons <lit ,1 $t> <cons <lit ,-1 ,t> _>>]
         ![_ <cons <lit ,1 <equation $s ,s>> _>])
       !<join _ <cons ,z _>> >> z]))

(define $make-solve
  (lambda [$resol]
   (match-lambda (multiset clause)
      ; empty clause
     {[<cons [_ <nil>] _>
       <REFUTE>]
      ; non-reflexive equation
      [<cons [_ <cons <lit ,-1 <equation $s ,s>> _>] _>
       <REFUTE>]
      [$p
       (let {[$q (resol (rename-problem 0 p))]}
         (if (include?/m clause p q) ; q \subseteq? p
           <SATURATED>
           (let {[$r (trim-clause {@p @q})]}
             ((make-solve resol) (debug-c r)))))]})))

(define $solve  (make-solve resolution))
(define $psolve (make-solve presolution))
(define $ssolve (make-solve sresolution))
