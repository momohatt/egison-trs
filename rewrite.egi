; Implementation of term rewriting system in Egison

(load-file "equation.egi")

; {equation} -> term -> term
; free variables of axioms and tm should be disjoint
(define $rewrite
  (lambda [$axioms $tm]
    (match [tm axioms] [term (multiset equation)]
      {[[<subterm-nonv $subtm $context>
         <cons <dequation <term-match ,subtm $sigma> $r> _>]
        (rewrite axioms (context (tsubst sigma r)))]
       [_ tm]
       })))

(assert-equal "rewrite 1"
  (rewrite axioms-of-nat (app "+" two one))
  three)
(assert-equal "rewrite 2"
  (rewrite axioms-of-groups (p (p x4 (i x4)) e))
  e)
(assert-equal "rewrite 3"
  (rewrite axioms-of-groups (p (p x4 x5) (i (p x4 x5))))
  e)
(assert-equal "rewrite 4"
  (rewrite axioms-of-groups (p e x))
  (p e x))
(assert-equal "rewrite 5"
  (rewrite axioms-of-nat (app "+" (app "S" x4) (app "S" x5)))
  (app "+" x4 (app "S" (app "S" x5))))

; {equation} -> {term} -> {term}
(define $rewrite-all
  (lambda [$axioms $tms]
    (match-all [tms axioms] [(multiset term) (multiset equation)]
      {[[<cons <subterm-nonv $subtm $context> _>
         <cons <equation <term-match ,subtm $sigma> $r> _>]
        (context (tsubst sigma r))]
      })))

(define $rewrite-loop
  (match-lambda [term (multiset term) (multiset equations)]
    {[[$goal <cons ,goal _> _]
      <PROVEN>]
     [[$goal $tgt $axioms]
      (rewrite-loop goal (debug/fn show-terms (rewrite-all axioms tgt)) axioms)]
     }))

(define $solve
  (match-lambda [(multiset equation) equation]
    {[[$axioms <dequation $l $r>] (rewrite-loop r {l} axioms)]
     }))

;;==============================================================================

(load-file "example.egi")

(assert-equal "rewrite-all-1"
  (solve axioms-of-nat (eql (app "+" two one) three))
  <PROVEN>)

(assert-equal "rewrite-all-2"
  ; with variable
  ; S(S(x)) + y = x + S(S(y))
  (solve axioms-of-nat (eql (app "+" (app "S" (app "S" x)) y)
                            (app "+" x (app "S" (app "S" y)))))
  <PROVEN>)


; (a * a')' = e
(define $g1' (i (p a a')))
; <PROVEN> with
;  (solve axioms-of-groups-complete g1)
(define $g1 (eql g1' e))

; (((b * c) * d)' * b)' * d' = c
(define $g2' (p (i (p (i (p (p b c) d)) b))
                (i d)))
; <PROVEN> with
;  (solve axioms-of-groups-complete g2)
(define $g2 (eql g2' c))
; (((b * c) * d)' * b)' * d'
; = (d' * (b * c)' * b)' * d'
; = (d' * c' * b' * b)' * d'
; = (d' * c' * e)' * d'
; = (d' * c')' * d'
; = c'' * d'' * d'
; = c'' * d * d'
; = c'' * e
; = c * e
; = c

; difficult...
(define $g3 (eql (p g1' g2') c))

; e * a = a
(define $g4 (eql (p e a) a))

; a' * a = e
(define $g5 (eql (p a' a) e))
