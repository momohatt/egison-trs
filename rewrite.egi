; Implementation of term rewriting system in Egison

(load-file "term.egi")

(define $equation
  (matcher
    {[<equation $ $> [term term]
      {[<Equation $l $r> {[l r]}] ; rewrite should be oriented left-to-right
       [_ {}]}]
     [$ something
      {[$tgt {tgt}]}]
     }))

(define $eql (lambda [$x $y] <Equation x y>))

(define $efv
  (lambda [$eq]
    (unique
      (match eq equation
        {[<equation $l $r> (append (fv l) (fv r))]}))))

(define $esubst
  (match-lambda [something equation]
    {[[$u <equation $l $r>] <Equation (tsubst u l) (tsubst u r)>]}))

(define $rewrite
  (lambda [$tgt $axiom]
    (unique
      (match-all [tgt axiom] [(multiset term) (multiset equation)]
        {[[<cons <subterm $subtm $context> _>
                 <cons <equation <unify ,subtm $sigma> $r> _>]
          (context (tsubst sigma r))
          ]
        }))))

(define $rewrite-loop
  (match-lambda [term (multiset term) (multiset term)]
    {[[$goal <cons ,goal _> _]
      <PROVEN>]
     [[_ <nil> _]
      <REFUTED>]
     [[$goal $tgt $axiom]
      (rewrite-loop goal (debug-term-set (rewrite tgt axiom)) axiom)]
     }))

(define $solve
  (match-lambda [equation (multiset equation)]
    {[[<equation $l $r> $axiom] (rewrite-loop r {l} axiom)]
     }))

;;======================= Knuth-Bendix completion ==============================

; rename free variables of each axioms so that they don't collide
(define $rename-problem
  (match-lambda [integer (list equation)]
    {[[$n <nil>]
      {}]
     [[$n <cons $e $es>]
      (let {[$u (zip (efv e)
                     ; n, n+1, ... の新しいvarを生成
                     (map (lambda $x <Var x>) (from n)))]}
        (cons (esubst u e)
              (rename-problem (+ n (length u)) es)))]}))

(define $critical-pairs
  (lambda [$axioms]
    (unique-unordered-pair
      (match-all (rename-problem 0 axioms) (multiset equation)
        {[<cons <equation $l2 $r2>
          <cons <equation
                  <subterm (& !<var _> <unify ,l2 $sigma>) $context>
                  $r1> _>>
          [(tsubst sigma r1) (tsubst sigma (context r2))]
        ]}))))

;;==============================================================================

(define $map-show
  (lambda [$show $set]
    (append-strings {"{" (concat-strings (map show set) ",\n ") "}"})))

(define $show-equation
  (match-lambda equation
    {[<equation $x $y>
       (append-strings {(show-term x) " = " (show-term y)})]
    }))

(define $show-equations
  (lambda [$eqs] (map-show show-equation eqs)))

(define $show-term-pairs
  (match-all-lambda (multiset [term term])
    [<cons [$t1 $t2] _>
     (append-strings {"[" (show-term t1) ", " (show-term t2) "]"})]))

(define $show-terms
  (lambda [$tms]
    (map-show show-term tms)))

(define $debug-term
  (macro [$tm]
    (io (do {[(print (show-term tm))]}
          (return tm)))))

(define $debug-term-set
  (macro [$tms]
    (io (do {[(print (show-terms tms))]}
          (return tms)))))

;;==============================================================================

(define $p (app "*" $1 $2)) ; product
(define $i (app "i" $1))    ; inverse
(define $e (app "e"))       ; 単位元

(define $a' (i a))
(define $b' (i b))
(define $c' (i c))
(define $d' (i d))

(define $x' (i x))
(define $y' (i y))
(define $z' (i z))
(define $w' (i w))

(define $axioms-of-groups
  {(eql (p (p x y) z) (p x (p y z)))
   (eql (p x x') e)            ; x * x' = e
   (eql (p x e) x)             ; x * e = x
  })

(define $axioms-of-groups-complete
  {@axioms-of-groups
   (eql (i (p y x)) (p x' y')) ; (y * x)' = x' * y'
   (eql (p y' (p y x)) x)      ; y' * (y * x) = x
   (eql (p x' x) e)            ; x' * x = e
   (eql (i e) e)               ; e' = e
   (eql (i x') x)              ; x'' = x
   (eql (p e x) x)             ; e * x = x
   (eql (p x (p x' y)) y)      ; x * (x' * y) = y
  })

; (a * a')' = e
(define $g1' (i (p a a')))
; <PROVEN> with
;  (solve g1 axioms-of-groups-complete)
(define $g1 (eql g1' e))

; (((b * c) * d)' * b)' * d' = c
(define $g2' (p (i (p (i (p (p b c) d)) b))
                (i d)))
; <PROVEN> with
;  (solve g2 axioms-of-groups-complete)
(define $g2 (eql g2' c))
; (((b * c) * d)' * b)' * d'
; = (d' * (b * c)' * b)' * d'
; = (d' * c' * b' * b)' * d'
; = (d' * c' * e)' * d'
; = (d' * c')' * d'
; = c'' * d'' * d'
; = c'' * d * d'
; = c'' * e
; = c * e
; = c

; difficult...
(define $g3 (eql (p g1' g2') c))

; e * a = a
(define $g4 (eql (p e a) a))

; a' * a = e
(define $g5 (eql (p a' a) e))

;;==============================================================================

(define $zero  (app "O"))
(define $one   (app "S" (app "O")))
(define $two   (app "S" (app "S" (app "O"))))
(define $three (app "S" (app "S" (app "S" (app "O")))))
(define $four  (app "S" (app "S" (app "S" (app "S" (app "O"))))))

(define $axioms-of-nat
   ; O + x = x
  {(eql (app "+" zero x) x)
   ; S(m) + n = m + S(n)
   (eql (app "+" (app "S" x) y) (app "+" x (app "S" y)))
   })

(define $p7 (eql (app "+" one two) three))
(define $p8 (eql (app "+" zero two) two))
