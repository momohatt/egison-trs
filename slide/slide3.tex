\documentclass[dvipdfmx,11pt,notheorems]{beamer}
%%%% 和文用 %%%%%
\usepackage{bxdpx-beamer}
\usepackage{pxjahyper}
\usepackage{minijs}%和文用
\usepackage{wrapfig}
\usepackage{txfonts}
\usepackage{minted}
\usepackage{ascmac} % screen
\usepackage{bussproofs}
% \usepackage{tikz}
\setminted{
    breaklines,
    mathescape=true,
    fontsize=\footnotesize,
    escapeinside=||,
}
\renewcommand{\kanjifamilydefault}{\gtdefault}%和文用

%%%% スライドの見た目 %%%%%
\usetheme{Madrid}
\usefonttheme{professionalfonts}
\setbeamertemplate{frametitle}[default][left]
\setbeamertemplate{navigation symbols}{}
\setbeamercovered{transparent}%好みに応じてどうぞ）
\setbeamertemplate{footline}[page number]
\setbeamerfont{footline}{size=\normalsize,series=\bfseries}
\setbeamercolor{footline}{fg=black,bg=black}
%%%%

%%%% 定義環境 %%%%%
\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{theorem}{定理}
\newtheorem{definition}{定義}
\newtheorem{proposition}{命題}
\newtheorem{lemma}{補題}
\newtheorem{corollary}{系}
\newtheorem{conjecture}{予想}
\newtheorem*{remark}{Remark}
\renewcommand{\proofname}{}
%%%%%%%%%

%%%%% フォント基本設定 %%%%%
\usepackage[T1]{fontenc}%8bit フォント
\usepackage{textcomp}%欧文フォントの追加
\usepackage[utf8]{inputenc}%文字コードをUTF-8
\usepackage{otf}%otfパッケージ
\usepackage{bm}%数式太字
%%%%%%%%%%

\newcommand{\code}[1]{\mintinline{text}{#1}}
\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\blue}[1]{{\color{blue} #1}}
\newcommand{\defines}{\ensuremath{\overset{\text{def}}{\,\Longleftrightarrow\,}}}
\newcommand{\underred}[2]{\underset{\color{red} #1}{\underline{\color{red} #2}}}


\title[]{paramodulationとsuperposition}%[略タイトル]{タイトル}
\author[]{服部桃子}%[略名前]{名前}
\institute[]{}%[略所属]{所属}
\date{\today}%日付
\begin{document}

\begin{frame}[plain]\frametitle{}
\titlepage %表紙
\end{frame}

\begin{frame}\frametitle{Contents}
\tableofcontents %目次
\end{frame}

\section{前回までのあらすじ}
\begin{frame}{前回までのあらすじ}
  \begin{itemize}
    \item 第1回: 導出原理とEgisonでの実装
    \item 第2回: 項書き換え系の話
    \begin{itemize}
      \item 停止性、合流性
      \item Lexicographic Path Order
      \item Knuth-Bendix完備化
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{前回までのあらすじ / 導出原理}
  \begin{block}{定義: resolvent}
    \begin{itemize}
      \item resolventの定義: 節$c, c_1, c_2$に対し以下を満たすリテラル$L_1, L_2$が存在するとき、$c$を$c_1, c_2$のresolventという
      \begin{itemize}
        \item $L_1 \in c_1$かつ$L_2^* \in c_2$
        \item $L_1, L_2$の\red{最汎単一化子$\theta$}が存在し、$c = (c_1\theta \setminus \{L_1 \theta\}) \cup (c_2\theta \setminus \{L_2^* \theta\})$
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{exampleblock}{}
    \begin{prooftree}
      \AxiomC{$\{\red{P(a, b)}\}$}
      \AxiomC{$\{\red{\lnot P(a, x)}, Q(x)\}$}
      \RightLabel{{\footnotesize $\theta = [b / x]$}}
      \BinaryInfC{$\{Q(b)\}$}
    \end{prooftree}
  \end{exampleblock}

  \begin{block}{}
    \begin{minted}{lisp}
(define $resolution ; resolventを求める
  (match-all-lambda (multiset (multiset literal))
    {[<cons |\colorbox{yellow}{<cons <lit ,1 \$t> \$xs>}|
       ; $t$との最汎単一化子が$\sigma$であるようなリテラル$\lnot s$
       <cons |\colorbox{yellow}{<cons <lit ,-1 (& <unify ,t \$sigma> \$s)> \$ys>}|
         _>>
      {@(subst-clause sigma xs) @(subst-clause sigma ys)}]}))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{前回までのあらすじ / 群の性質を示す}
  \begin{itemize}
    \item 群の公理から群の性質を示す
    \begin{itemize}
      \item 等式は単なる2項述語なので\colorbox{yellow}{等式の公理}も必要
    \end{itemize}
    \begin{minted}{lisp}
(define $p3
  {@axioms-of-groups
   |\colorbox{yellow}{@axioms-of-equality}|
   |\colorbox{yellow}{@congruence-groups}|
   ; (negation of) the goal: e * x = x
   {<Lit -1 <Compound "=" <Compound "*" {e e1}> e1>>}})

> (solve p3) ; => 現実的な時間では終わらない
    \end{minted}
  \end{itemize}
  \begin{block}{目標}
    Egisonで実装した導出原理のプログラムを改良し、探索空間を減らす
    \begin{itemize}
      \item paramodulation
      \item superposition
    \end{itemize}
  \end{block}
\end{frame}

\section{paramodulation}

\begin{frame}\frametitle{Contents}
\tableofcontents[currentsection]
\end{frame}

\begin{frame}{paramodulation}

  {\Large
  \begin{prooftree}
    \AxiomC{$C \lor s \doteq t$}
    \AxiomC{$D \lor P[s']$}
    \BinaryInfC{$\sigma (C \lor D \lor P[t])$}
  \end{prooftree}
  }
  \begin{itemize}
    \item 導出原理で等式を直接扱う手法
    \item 上のような規則を追加
    \begin{itemize}
      \item $s \doteq t$は「$s = t$または$t = s$」
      \item $\sigma$は$s$と$s'$の最汎単一化子 \, ($\sigma = \text{mgu}(s, s')$)
    \end{itemize}

    \item 等式の公理は\blue{reflexivity(反射性)以外は}不要になる
    \begin{itemize}
      \item functional reflexivityも必要とされる
      \begin{itemize}
        \item $f(x_1, \ldots, x_n) = f(x_1, \ldots, x_n)$
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{paramodulation / completeness}
\begin{block}{定理: Refutational completeness}
$S$がnormal model\footnote{"="が等号として解釈されるモデル}を持たないならば、
$S$にreflexivityとfunctional reflexivityを加えたものからparamodulationと導出原理によって空節を導くことができる
\end{block}

\underline{証明(概略)}:

\vspace{5pt}
普通の導出原理の完全性を利用して、
「導出原理 + 等式の公理で導出可能」ならば「導出原理 + paramodulation + reflexivityで導出可能」を示す
\end{frame}

\begin{frame}{paramodulation / completeness}
  \begin{itemize}
    \item 例えば導出原理+(1-ary)functional congruenceを用いている場合...
    \begin{prooftree}
      \AxiomC{$\lnot (x = x') \lor f(\ldots, x, \ldots) = f(\ldots, x', \ldots)$}
      \AxiomC{$C \lor s = t$}
      \BinaryInfC{$C \lor f(\ldots, s, \ldots) = f(\ldots, t, \ldots)$}
    \end{prooftree}
    paramodulation + functional reflexivityで次のように示せる
    \begin{prooftree}
      \AxiomC{$f(\ldots, x, \ldots) = f(\ldots, \red{[x]}, \ldots) \lor C$}
      \AxiomC{$s = t$}
      \RightLabel{\blue{$\sigma = [s / x]$}}
      \BinaryInfC{$f(\ldots, \blue{s}, \ldots) = f(\ldots, \red{t}, \ldots) \lor C$}
    \end{prooftree}

    \vspace{10pt}
    \item 他、(1-ary) predicate congruenceを用いている場合や、対称性・推移性を用いている場合も同様の議論
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{paramodulation / 実装}
  \begin{block}{prop}
    \begin{minted}{lisp}
; predicateとは別にequationを用意する
(define $prop
  (matcher
    {[<pred $ $> [string (list term)]
       {[<Pred $p $a> {[p a]}]
        [_ {}]}]
     [|\colorbox{yellow}{<equation \$ \$>}| [term term]
       ; unordered-pairのようにマッチ($l \doteq r$を表現)
      {[<Equation $l $r> {|\colorbox{yellow}{[l r] [r l]}|}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (punify t s)]}]
     [<subterm $ $> [term something]
      {[$s (psubterm s)]}]
     [$ something
       {[$tgt {tgt}]}]}))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{paramodulation / 実装}
  \begin{block}{subterm}
    \begin{minted}{lisp}
(define $prop
  (matcher
    {(...)
     ; subtermとその「環境」(term -> propの関数)のペアにマッチ
     |\colorbox{yellow}{[<subterm \$ \$> [term something]}|
      |\colorbox{yellow}{{[\$s (psubterm s)]}]}|
     [$ something
       {[$tgt {tgt}]}]}))
    \end{minted}
  \end{block}

  \begin{block}{}
    \begin{minted}{lisp}
;; term -> {term, term -> term}
(define $subterm
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm $x $env> $xs'>>>
       (let {[$env'
              (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose env' env)])]
     [$t [t id]]}))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{paramodulation / 実装}
  \begin{block}{resolution}
    \begin{minted}{lisp}
(define $resolution
  (match-all-lambda (multiset (multiset literal))
     ; paramodulation
    {[<cons <cons <lit ,1 <equation $s $t>> $xs>
       <cons <cons <lit $sign
           ; env[s'], s'は変数でない, sigma = mgu(s, s')
           |\colorbox{yellow}{<subterm (& !<var \_> <unify ,s \$sigma> \$s') \$env>}|> $ys>
         _>>
      (csubst sigma {@xs @ys <Lit sign |\colorbox{yellow}{(env t)}|>})
     ]
     ; 普通のresolution
     [<cons <cons <lit ,1 $t> $xs>
       <cons <cons <lit ,-1 (& <unify ,t $sigma> $s)> $ys>
         _>>
      (csubst sigma {@xs @ys})
     ]}))
    \end{minted}
  \end{block}
\end{frame}

\section{superposition}

\begin{frame}\frametitle{Contents}
\tableofcontents[currentsection]
\end{frame}
\begin{frame}{superposition}
  \begin{itemize}
    \item 項、等式、リテラル、節すべてに順序(重み)をつけ、一番重いものを書き換える
    \begin{itemize}
      \item 書き換えの結果軽くなるように
    \end{itemize}
    \item 参考文献
    \begin{enumerate}
      \item Bachmair, Leo, and Harald Ganzinger. \textit{Rewrite-based equational theorem proving with selection and simplification.} Journal of Logic and Computation 4.3 (1994): 217-247.
      \item \url{http://resources.mpi-inf.mpg.de/departments/rg1/teaching/autrea-ss12/script/script23.pdf}
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{superposition / orderings}
  \begin{block}{orderのmultiset拡張}
    $\succ$を集合$S$上のorderingとすると、$S$の要素のmultiset上への拡張$\succ_{mul}$は次のように定義される
    \vspace{-10pt}
    \[
    M \succ_{mul} N \defines
    \left\{\begin{array}{l}
    (i) \, M \not= N \\
    (ii) \, \underred{\# x \in N}{N(x)} > M(x) \Rightarrow \exists y \succ x.\, M(y) > N(y) \\
    \end{array}
    \right.
    \]
  \end{block}

  \begin{exampleblock}{例}
    \vspace{-10pt}
    \begin{align*}
      \{1, 2, 2, 3\} &>_{mul} \{1, 1, 2, 3\} \\
      \{1, 2, 3\} &<_{mul} \{1, 1, 2, 3\}
    \end{align*}
  \end{exampleblock}
\end{frame}

\begin{frame}{superposition / orderings}
  \begin{block}{等式の順序}
    \[
    s = t \, \red{\succ^e} \, u = v \defines \{s, t\} \succ_{mul} \{u, v\}
    \]
  \end{block}

  \begin{block}{リテラルの順序}
    \vspace{-10pt}
    \begin{align*}
      L(s = t) \, \red{\succ^o} \, L(u = v) &\defines M(L(s = t))\,  (\succ_{mul})_{mul} \, M(L(u = v)) \\
      L(s, t) &= (s = t) \text{または} (s \not= t) \\
      M(s = t) &= \{\{s\}, \{t\}\} \quad M(s \not= t) = \{\{s,\bot\},\{t ,\bot\}\}
    \end{align*}
  \end{block}

  \begin{exampleblock}{例}
    \vspace{-10pt}
    \begin{align*}
      S(S(O)) = S(O) \succ^e S(S(O)) = O \\
      S(S(O)) = S(O) \prec^o S(S(O)) \not= O
    \end{align*}
  \end{exampleblock}
\end{frame}

\begin{frame}{superposition / 推論規則}
  \begin{block}{reductive}
    $\succ$をreduction orderingとする。

    節$C \lor s = t$が$s = t$について\red{reductive}であるとは、
    \begin{enumerate}
      \item $t \not\succeq s$
      \item リテラル$s = t$はリテラルの順序について$C \lor s = t$でstrictに極大

      ($\lnot\exists x \in C. \, x \succeq^o (s = t)$)
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}{superposition / 推論規則}
  Superposition Left:
  \begin{prooftree}
    \AxiomC{$C \lor s = t$}
    \AxiomC{$u[s'] \not= v \lor D$}
    \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
    \BinaryInfC{$(u[t] \not= v \lor C \lor D) \sigma$}
  \end{prooftree}

  Superposition Right:
  \begin{prooftree}
    \AxiomC{$C \lor s = t$}
    \AxiomC{$u[s'] = v \lor D$}
    \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
    \BinaryInfC{$(u[t] = v \lor C \lor D) \sigma$}
  \end{prooftree}

  Equality Resolution:
  \begin{prooftree}
    \AxiomC{$u \not= v \lor C$}
    \RightLabel{{\footnotesize $\sigma = \text{mgu}(u, v)$}}
    \UnaryInfC{$C \sigma$}
  \end{prooftree}

  Equality Factoring:
  \begin{prooftree}
    \AxiomC{$C \lor s = t \lor s' = t'$}
    \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
    \UnaryInfC{$(C \lor t \not= t' \lor s' = t')\sigma$}
  \end{prooftree}
\end{frame}

\begin{frame}{superposition / 推論規則}
  \begin{block}{Superposition Left}
    \begin{prooftree}
      \AxiomC{$C \lor s = t$}
      \AxiomC{$u[s'] \not= v \lor D$}
      \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
      \BinaryInfC{$(u[t] \not= v \lor C \lor D) \sigma$}
    \end{prooftree}
    \vspace{-10pt}

    \begin{itemize}
      \item 節$(C \lor s = t)\sigma$は$s\sigma = t\sigma$についてreductive
      \item $v\sigma \not\succeq u\sigma$, $u\sigma \not= v\sigma$は節$(u \not= v \lor D)\sigma$に含まれるリテラルの中で極大
      \item $s'$は変数でない
    \end{itemize}
  \end{block}

  \begin{block}{Superposition Right}
    \begin{prooftree}
      \AxiomC{$C \lor s = t$}
      \AxiomC{$u[s'] = v \lor D$}
      \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
      \BinaryInfC{$(u[t] = v \lor C \lor D) \sigma$}
    \end{prooftree}
    \vspace{-10pt}

    \begin{itemize}
      \item 節$(C \lor s = t)\sigma$は$s\sigma = t\sigma$についてreductive
      \item 節$(D \lor u = v)\sigma$は$u\sigma = v\sigma$についてreductive
      \item $s'$は変数でない
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{superposition / 推論規則}
  \begin{block}{Equality Resolution}
    \begin{prooftree}
      \AxiomC{$u \not= v \lor C$}
      \RightLabel{{\footnotesize $\sigma = \text{mgu}(u, v)$}}
      \UnaryInfC{$C \sigma$}
    \end{prooftree}

    \begin{itemize}
      \item $u\sigma\not=v\sigma$は節$(u\not=v \lor C)\sigma$に含まれるリテラルの中で極大
    \end{itemize}
  \end{block}

  \begin{block}{Equality Factoring}
    \begin{prooftree}
      \AxiomC{$C \lor s = t \lor s' = t'$}
      \RightLabel{{\footnotesize $\sigma = \text{mgu}(s, s')$}}
      \UnaryInfC{$(C \lor t \not= t' \lor s' = t')\sigma$}
    \end{prooftree}

    \begin{itemize}
      \item $t\sigma \not\succ s\sigma$かつ$t'\sigma \not\succ s'\sigma$
      \item $s\sigma = t\sigma$は節$(C \lor s=t \lor s'=t')\sigma$に含まれるリテラルの中で極大
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{superposition / 実装}
  \begin{itemize}
    \item 実装の詳細は面白いところがないので割愛します
    \item 動いているところ: demo
  \end{itemize}
\end{frame}

\end{document}
