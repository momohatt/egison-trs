; term-related definition

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (unify {} {[s t]})]}]
     [<term-match ,$t $> something
      {[$s (term-match {} {[s t]})]}]
     ; [<subterm $ $> [term something]
     ;  {[$s (subterm s)]}]
     ; subterm at non-variable position
     [<subterm-nonv $ $> [term something]
      {[$s (subterm-nonv s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $var (lambda $n <Var n>))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs> <Compound x xs>]})))

(define $tsubst
  (match-lambda [something term]
    {[[$u <var $n>]
       (match u (multiset [integer term])
         {[<cons [,n $t] _> t] ; subst規則があればsubst
          [_ <Var n>]})]       ; なければそのまま
     [[$u <compound $f $xs>]
       <Compound f (map (tsubst u $1) xs)>]}))

;; term -> {term, term -> term}
(define $subterm
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm $x $context> $xs'>>>
       (let {[$context' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose context context')])]
     [$t [t id]]}))

;; term -> {term, term -> term}
(define $subterm-nonv
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm-nonv $x $context> $xs'>>>
       (let {[$context' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose context context')])]
     [(& !<var _> $t) [t id]]}))

(assert-equal "subterm-nonv"
  (map fst (subterm-nonv (app "+" x (app "S" y))))
  {(app "S" y) (app "+" x (app "S" y))})

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>)))

(define $fv
  (match-all-lambda term
    {[(occur $v) v]}))

(define $update
  (match-lambda [[string term] something]
    {[[[$x $t] $sigma] {@sigma [x (tsubst sigma t)]}]}))

(define $unify
  (lambda [$sigma $term-pairs]
    (match term-pairs (list (unordered-pair term))
      {[<nil> (Just sigma)]
       [<cons [<var $x> (& <compound _ _> (occur ,x))] _>
        Nothing]
       [<cons [<var $x> $t] $ps>
        (let {[$ps' (map (lambda [$t1 $t2] [(tsubst {[x t]} t1) (tsubst {[x t]} t2)]) ps)]}
          (match (unify sigma ps') (maybe something)
            {[(nothing) Nothing]
             [(just $sigma') (Just (update [x t] sigma'))]}))]
       [<cons [<compound $f $xs> <compound ,f $ys>] $p'>
        (if (eq? (length xs) (length ys))
            (unify sigma {@(zip xs ys) @p'})
            Nothing)]
       [_ Nothing]})))

(define $term-match
  (lambda [$sigma $term-pairs]
    (match term-pairs (list [term term])
      {[<nil> (Just sigma)]
       [<cons [<compound $f $xs>
               <compound ,f (& $ys ?(lambda [$ys] (eq? (length xs) (length ys))))>] $p'>
        (term-match sigma {@(zip xs ys) @p'})]
       [<cons [<var $x> $t] $p'>
        (match sigma (multiset [string term])
          {[<cons [,x ,t]  _>  (term-match sigma p')]
           [<cons [,x $t'] _> Nothing]
           [_        (term-match (cons [x t] sigma) p')]})]
       [_ Nothing]
        })))

(term-match {} {[(app "+" (app "S" x) y) (app "+" one two)]})

; ================================== LPO =======================================

(define $weight
  (match-lambda string
    {[,"O" 0]
     [,"S" 1]
     [,"+" 2]
     [,"e" 1]
     [,"a" 1]
     [,"b" 1]
     [,"c" 1]
     [,"d" 1]
     [,"*" 3]
     [,"i" 4]
     [,"f" 2]
     [,"g" 3]
     [$s (io (do {(print (S.concat {"WARNING: weight of " s " is undefined"}))}
              (return 0)))]}))

; assumes that the two input lists have the same length
(define $lpo?
  (match-lambda [(list term) (list term)]
    {[[<cons $s $sx> <cons ,s $tx>]
        (lpo? sx tx)]
     [[<cons $s _> <cons ?(succ? s $) _>] #t]
     [_ #f]}))

(define $terminate?
  (lambda [$x $ts]
    (all (succ? x $) ts)))

(define $sigord
  (lambda [$f $g]
    (gt? (weight f) (weight g))))

; Lexicographic Path Order
(define $ord-t
  (lambda [$x $y]
    (match [x y] [term term]
      {[[_ ,x] <Equal>]
       [[,bottom _] <Less>]
       [[_ ,bottom] <Greater>]
       [(| [<compound $f $ss>
            <compound ,f (& ?(lpo? ss $) ?(terminate? x $))>]
           [<compound _ <join _ <cons ,y _>>>
            _]
           [<compound _ <join _ <cons $s _>>>
            ?(succ? s $)]
           [<compound $f _>
            <compound ?(sigord f $) ?(terminate? x $)>])
          <Greater>]
       [(| [<compound $f
              (& (later ?(lpo? ss $)) ?(terminate? y $))>
            <compound ,f $ss>]
           [_
            <compound _ <join _ <cons ,x _>>>]
           [(later ?(succ? s $))
            <compound _ <join _ <cons $s _>>>]
           [<compound $f ?(terminate? y $)>
            <compound ?(sigord $ f) _>])
          <Less>]
       [_ <Undefined>]})))

; x >? y?
(define $succ?
  (lambda [$x $y]
    (eq? (ord-t x y) <Greater>)))

;;==============================================================================

; variables
(define $x (var 0))
(define $y (var 1))
(define $z (var 2))
(define $w (var 3))

(define $x4 (var 4))
(define $x5 (var 5))
(define $x6 (var 6))
(define $x7 (var 7))
(define $x8 (var 8))
(define $x9 (var 9))

(define $bottom (var -1))

; constants
(define $a (app "a"))
(define $b (app "b"))
(define $c (app "c"))
(define $d (app "d"))

(define $show-term
  (match-lambda term
    {[<var ,0> "x"]
     [<var ,1> "y"]
     [<var ,2> "z"]
     [<var ,3> "w"]
     [<var $x> (S.concat {"x" (show x)})]
     [<compound $f ,{}> f]
     [<compound ,"+" <cons (& <compound ,"+" _> $x) <cons $y <nil>>>>
       (S.concat {"(" (show-term x) ") + " (show-term y)})]
     [<compound ,"+" <cons $x <cons $y <nil>>>>
       (S.concat {(show-term x) " + " (show-term y)})]
     [<compound ,"*" <cons (& <compound ,"*" _> $x) <cons $y <nil>>>>
       (S.concat {"(" (show-term x) ") * " (show-term y)})]
     [<compound ,"*" <cons $x <cons $y <nil>>>>
       (S.concat {(show-term x) " * " (show-term y)})]
     [<compound $f $xs>
       (S.concat {f "(" (S.intercalate ", " (map show-term xs)) ")"})]
    }))

(define $show-terms
  (col-show/fn show-term $1))
