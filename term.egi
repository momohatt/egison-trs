; term-related definition

(load-file "utils.egi")

(define $term
  (matcher
    {[<var $> integer
      {[<Var $i> {i}]
       [_ {}]}]
     [<compound $ $> [string (list term)]
      {[<Compound $s $l> {[s l]}]
       [_ {}]}]
     [<unify ,$t $> something
      {[$s (unify {} {[s t]})]}]
     [<term-match ,$t $> something
      {[$s (term-match {} {[s t]})]}]
     ; subterm at non-variable position
     [<subterm-nonvar $ $> [term something]
      {[$s (subterm-nonvar s)]}]
     [$ something
      {[$tgt {tgt}]}]}))

(define $var (lambda $n <Var n>))

(define $app
  (cambda $xs
    (match xs (list something)
      {[<cons $x $xs> <Compound x xs>]})))

(define $tsubst
  (match-lambda [something term]
    {[[$u <var $n>]
       (match u (multiset [integer term])
         {[<cons [,n $t] _> t] ; subst規則があればsubst
          [_ <Var n>]})]       ; なければそのまま
     [[$u <compound $f $xs>]
       <Compound f (map (tsubst u $1) xs)>]}))

;; term -> {term, term -> term}
(define $subterm
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm $x $context> $xs'>>>
       (let {[$context' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose context context')])]
     [$t [t id]]}))

;; term -> {term, term -> term}
(define $subterm-nonvar
  (match-all-lambda term
    {[<compound $f <join $xs <cons <subterm-nonvar $x $context> $xs'>>>
       (let {[$context' (lambda [$x] <Compound f (append xs (cons x xs'))>)]}
         [x (compose context context')])]
     [(& !<var _> $t) [t id]]}))

(define $occur
  (pattern-function [$v]
    (| <var v>
       <compound _ <join _ <cons (occur v) _>>>)))

(define $fv
  (match-all-lambda term
    {[(occur $v) v]}))

(define $update
  (match-lambda [[string term] something]
    {[[[$x $t] $sigma] {@sigma [x (tsubst sigma t)]}]}))

;; {[var term]} -> {[term term]} -> {[var term]}
(define $unify
  (lambda [$sigma $term-pairs]
    (match term-pairs (list (unordered-pair term))
      {[<nil> (Just sigma)]
       [<cons [<var $x> <var ,x>] $ps>
        (unify sigma ps)]
       [<cons [<var $x> (& <compound _ _> (occur ,x))] _>
        Nothing]
       [<cons [<var $x> $t] $ps>
        (let {[$ps' (map (lambda [$t1 $t2] [(tsubst {[x t]} t1) (tsubst {[x t]} t2)]) ps)]}
          (match (unify sigma ps') (maybe something)
            {[(nothing) Nothing]
             [(just $sigma') (Just (update [x t] sigma'))]}))]
       [<cons [<compound $f $xs> <compound ,f $ys>] $p'>
        (if (eq? (length xs) (length ys))
            (unify sigma {@(zip xs ys) @p'})
            Nothing)]
       [_ Nothing]})))

;; {[var term]} -> {[term term]} -> {[var term]}
(define $term-match
  (lambda [$sigma $term-pairs]
    (match term-pairs (list [term term])
      {[<nil> (Just sigma)]
       [<cons [<compound $f $xs>
               <compound ,f (& $ys ?(lambda [$ys] (eq? (length xs) (length ys))))>] $p'>
        (term-match sigma {@(zip xs ys) @p'})]
       [<cons [<var $x> $t] $p'>
        (match sigma (multiset [string term])
          {[<cons [,x ,t]  _>  (term-match sigma p')]
           [<cons [,x $t'] _> Nothing]
           [_        (term-match (cons [x t] sigma) p')]})]
       [_ Nothing]
        })))

; ================================== LPO =======================================

; ordering of function symbols, given by user
(define $weight
  (match-lambda string
    {[,"O" 0]
     [,"W" 0]
     [,"S" 1]
     [,"B" 2]
     [,"+" 2]
     [,"e" 1]
     [,"a" 1]
     [,"b" 1]
     [,"c" 1]
     [,"*" 3]
     [,"i" 4]
     [,"f" 2]
     [,"g" 3]
     [$s (io (do {(print (S.concat {"WARNING: weight of " s " is undefined"}))}
              (return 0)))]}))

; assumes that the two input lists have the same length
(define $lpo?
  (match-lambda [(list term) (list term)]
    {[[<cons $s $sx> <cons ,s $tx>]
        (lpo? sx tx)]
     [[<cons $s _> <cons ?(succ? s $) _>] #t]
     [_ #f]}))

(define $terminate?
  (lambda [$x $ts]
    (all (succ? x $) ts)))

(define $sigord
  (lambda [$f $g]
    (gt? (weight f) (weight g))))

; Lexicographic Path Order
(define $ord-t
  (lambda [$x $y]
    (match [x y] [term term]
      {[[_ ,x] <Equal>]
       ; XXX: 'bottom' is used in superposition
       [[,bottom _] <Less>]
       [[_ ,bottom] <Greater>]
       [(| [<compound $f $ss>
            <compound ,f (& ?(lpo? ss $) ?(terminate? x $))>]
           [<compound _ <join _ <cons ,y _>>>
            _]
           [<compound _ <join _ <cons $s _>>>
            ?(succ? s $)]
           [<compound $f _>
            <compound ?(sigord f $) ?(terminate? x $)>])
          <Greater>]
       [(| [<compound $f
              (& (later ?(lpo? ss $)) ?(terminate? y $))>
            <compound ,f $ss>]
           [_
            <compound _ <join _ <cons ,x _>>>]
           [(later ?(succ? s $))
            <compound _ <join _ <cons $s _>>>]
           [<compound $f ?(terminate? y $)>
            <compound ?(sigord $ f) _>])
          <Less>]
       [_ <Undefined>]})))

; x \succ? y?
(define $succ?
  (lambda [$x $y]
    (eq? (ord-t x y) <Greater>)))

;;==============================================================================

; bottom (used in superposition)
(define $bottom (var -1))

(define $show-term
  (match-lambda term
    {[<var $x> (S.concat {"x" (show x)})]
     [<compound $f ,{}> f]
     [<compound ,"+" <cons (& <compound ,"+" _> $x) <cons $y <nil>>>>
       (S.concat {"(" (show-term x) ") + " (show-term y)})]
     [<compound ,"+" <cons $x <cons $y <nil>>>>
       (S.concat {(show-term x) " + " (show-term y)})]
     [<compound ,"*" <cons (& <compound ,"*" _> $x) <cons $y <nil>>>>
       (S.concat {"(" (show-term x) ") * " (show-term y)})]
     [<compound ,"*" <cons $x <cons $y <nil>>>>
       (S.concat {(show-term x) " * " (show-term y)})]
     [<compound $f $xs>
       (S.concat {f "(" (S.intercalate ", " (map show-term xs)) ")"})]
    }))

(define $show-terms
  (col-show/fn show-term $1))
