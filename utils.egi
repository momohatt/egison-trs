(define $unordered-pair
  (lambda [$m]
    (matcher
      {[<pair $ $> [m m] {[[$x $y] {[x y] [y x]}]}]
      [$ [something] {[$tgt {tgt}]}]})))

; cannot be done with 'unique/m (unordered-pair something)'
(define $unique-unordered-pair
  (lambda [$xs]
    (letrec {[$loop-fn
              (lambda [$xs $ys]
                (match [xs ys] [(list (unordered-pair something))
                                (multiset (unordered-pair something))]
                  {[[<nil> _] ys]
                   [[<cons <pair $l $r> $rs> <cons <pair ,l ,r> _>] (loop-fn rs ys)]
                   [[<cons $x $rs>  _] (loop-fn rs {@ys x})]}))]}
      (loop-fn xs {}))))

(unique-unordered-pair {[1 2] [2 1]})

(define $compare-c/fn
  (lambda [$ord $c1 $c2]
    (match [c1 c2] [(list something) (list something)]
      {[[<nil> <nil>] <Equal>]
       [[<nil> _] <Less>]
       [[_ <nil>] <Greater>]
       [[<cons $x $xs> <cons ,x $ys>] (compare-c/fn ord xs ys)]
       [[<cons $x _> <cons $y _>] (ord x y)]})))

(define $neq? (lambda [$x $y] (not (eq? x y))))

; ============================== pretty printing ===============================

(define $append-strings
  (lambda [$strs]
    (foldl (lambda [$acc $x] (append-string acc x)) "" strs)))

(define $concat-strings
  (lambda [$strs $sep]
    (append-strings
      (match-all strs (list string)
        {[<nil> ""]
         [<join _ <cons $x !<nil>>> (append-string x sep)]
         [<join _ <cons $x <nil>>> x]
         }))))
