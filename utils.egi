(define $unordered-pair
 (lambda [$m]
  (matcher
    {[<pair $ $> [m m] {[[$x $y] {[x y] [y x]}]}]
     [$ [something] {[$tgt {tgt}]}]})))

(define $positive?
  (lambda $x (gt? x 0)))

; ============================== pretty printing ===============================

(define $append-strings
  (lambda [$strs]
    (foldl (lambda [$acc $x] (append-string acc x)) "" strs)))

(define $concat-strings
  (lambda [$strs $sep]
    (append-strings
      (match-all strs (list string)
        {[<nil> ""]
         [<join _ <cons $x !<nil>>> (append-string x sep)]
         [<join _ <cons $x <nil>>> x]
         }))))

(define $show-term
  (match-lambda term
    {[<var ,0> "x"]
     [<var ,1> "y"]
     [<var ,2> "z"]
     [<var ,3> "w"]
     [<var $x> (append-strings {"x" (show x)})]
     [<compound $f ,{}> f]
     [<compound ,"=" <cons $x <cons $y <nil>>>>
       (append-strings {(show-term x) " = " (show-term y)})]
     [<compound ,"+" <cons $x <cons $y <nil>>>>
       (append-strings {(show-term x) " + " (show-term y)})]
     [<compound ,"*" <cons $x <cons $y <nil>>>>
       (append-strings {"(" (show-term x) " * " (show-term y) ")"})]
     [<compound $f $xs>
       (append-strings {f "(" (concat-strings (map show-term xs) ", ") ")"})]
     [<equation $x $y>
       (append-strings {(show-term x) " = " (show-term y)})]
    }))

(define $show-lit
  (match-lambda literal
    {[<lit ,1  $t> (show-term t)]
     [<lit ,-1 $t> (append-string "~" (show-term t))]}))

(define $show-clause
  (lambda [$cls]
    (let {[$x (concat-strings (map show-lit cls) ", ")]}
      (append-strings {"{" x "}"}))))

(define $show-clauses
  (lambda [$clss]
    (let {[$x (concat-strings (map show-clause clss) "\n ")]}
      (append-strings {"{" x "}"}))))

(define $debug-c
  (macro [$expr]
    (io (do {[(print (show-clauses expr))]}
          (return expr)))))
